/*Переменные — это контейнер для таких значений, как числа, используемые в сложении, или строка, которую мы могли бы использовать как часть предложения. Но одна из особенностей переменных — их значение может меняться.
Ещё одна особенность переменных заключается в том, что они могут содержать практически все, а не только строки и числа. Переменные могут также содержать сложные данные и даже целые функции.
Заметьте: мы говорим, что переменные содержат значения. Это важное различие. Переменные не являются самими значениями; они представляют собой контейнеры для значений. Представьте, что они похожи на маленькие картонные коробки, в которых вы можете хранить вещи.
Чтобы использовать переменную, вы сначала должны её создать, или, если быть точнее, объявить переменную. Чтобы сделать это, мы вводим ключевое слово var, let и const за которым следует имя, которое вы хотите дать своей переменной:
*/

// Exercise 1

var a = '34'/'gh';
var b = 20*'gh';
var c;
c = c + " строка!";
console.log(a);
console.log(b);
console.log(c);


a = 34;
b = 20;
a = a + 2;
b = b - 5;
c = "Новая строка!";

console.log(a);
console.log(b);
console.log(c);

// Exercise 2

// let res = prompt('Введите сумму зарплаты', );
// alert(`Премия 15%. На руки ${res *= 1.15}`);
// alert(`Налоги -10%. На руки ${res -= res * 0.1}`);
// alert(`В магазине -190. Осталось ${res -= 190}`);
// alert(`Жене половину отдал. Осталось ${res /= 2}`);
//? Мы обьявили переменную res и вывели ее с помощью функций prompt и alert в модальное окно. Функция prompt принимает два аргумента, это title - наше сообщение по типу - 'Введите сумму зарплаты' и значение default - тоесть любое значение которое попадет в наше модальное окно, к примеру по умолчанию установлено 1000, но его можно изменить в модальном окне и указать любое другое значение. То есть мы для res по умолчанию присвоили значение в 1000. Далее при помощи функции alert в модальном окне мы выводим последующие сообщения. Для того чтобы получать в функции alert некие параметры расчетов, нам необходимо аргумент (наше сообщение) записать в темплейт строку `` что позволит нам вставить в нее сообщение и некий объект ${}, а именно нашу переменную res, и уже в объектных скобках {} мы можем указать некое математическое выражение, либо другие объекты или примитивные типы данных.

// Exercise 4

// alert('Make up a number');
// alert('Multiply the resulting number by 2');
// alert('Add 7 to the result');
// let userNumber = prompt('Put what you get', );
// alert(`Your number is ${(userNumber -= 7) / 2}`);
//? Суть задачи угадать число пользователя, для начала мы задаем некие условия с помощью функции alert, после чего мы объявляем переменную UserNumber приравнивая ей значение default из функции prompt, после при помощи функции alert и темплейт строки вписываем некое сообщение которое содержит в себе объект, а именно userNumber к которому применено некое математическое выражение. Как итог мы получаем сообщение и загаданное число пользователя.

// Exercise 5
// let sum = 0;
// for (let i = 1; i <= 10; i++){
//     sum += i;
//     document.write("<p>i="+i+", sum="+sum+"</p>")
// };

// Суть задачи попросить пользователя ввести три раза имя и фамилию, к примеру студентов через модальное окно, указанну информацию необходимо вывести в тело документа.

// let studentName;
// for (let i = 1; i <= 3; i++){
//     studentName = prompt('Введите имя и фамилию студента',);
//     document.write("<ul><li>Имя и фамилия студента: " + studentName + "</li></ul>");
// };

// сначала мы объявили переменную studentName, после создали цикл for, условием данного цикла являеться объявление счетчка некой переменной (вообще не имеет никакого значения или привязки к той переменной что будет в неком коде запсанном в {}), далее задаем само условие, так как for возвращает только true а при false цикл останавливается, то мы задали чтобы наш цикл повторился 3 раза, так как отсчет ведется всегда от 0 то соответственно 0,1,2 - все эти значения меньше 3, после мы задаем параметр изменения счетчика, ставим инкримент к нашему счетчику, таким образом при каждом цикле будет прибавлятся 1 пока значение нашего счетчика не достигнет условия false, а именно не будет = 3 или больше 3. После описанного цикла мы задаем выражение нашему циклу, а именно присваиваем нашей переменной studentName значение, которое будет вводиться при помощи функции prompt в модальном окне. В итоге при помощи функции document.write мы выводим полученную информацию от пользователя в тело документа

// Exercise 6

c = 24.8 - 24.8 / 5;
console.log(c);
b = c / 5;
console.log(b);
a = (24.8 - c) / 5;
console.log(a);
summ = a + b + c;
console.log(summ);

function funcName() {
    let c = 24.8 - 24.8 / 5;
    b = c / 5;
    a = (24.8 - c) / 5;
    summ = a + b + c;
    document.write("<p>"+a+"</p>", "<p>"+b+"</p>", "<p>"+c+"</p>","<h3> summ = "+a+"+"+b+"+"+c+"="+summ+"</h3>");
}
funcName();


//----------------------

const objectA = {
    a: 10,
    b:true
}
console.log(objectA);

const copyOfA = objectA
copyOfA.a = 20
console.log(copyOfA);
console.log(objectA);
copyOfA.c = 'abc'
console.log(objectA);

// Функция 
//Объявление функции происходит при помощи ключевого слова function, далее идет имя функции, например d, а далее идет синтаксис функции () круглые скобки, после них в фигурных скобках {} идет тело функции, некий код.

function d() {
    console.log('Hey there')
};
d()
d = 5;
// d()

// Стрелочная функция () =>, с ее помощу мы можем убрать ключевое слово function. 

const f = () => {
    console.log('Hello')
};
f() //вызов функции
// f = 10;

// Объекты
//Свойства и значение Объектов, а именно пары "ключ:значение" записываються в фигурных скобках {}, тоесть все что внутри {это свойства и значения объекта с именем переменной myCity}

const myCity = {
    city: 'New York',
    popular: true,
    country: 'USA'
}
console.log(myCity.city) // Вывод конкретного свойства с помощью точечной записи, тоесть myCity.city, тоесть мы выводим конкретное значение свойства city объекта myCity, таким образом в консоль выводиться не весь объект, а конкретное его значение.

myCity.city = 'Las Vegas'; // Изменение свойств объекта с помощью точечной записи
console.log(myCity.city) 

myCity.population = 1000000; // Добавление свойств в объект с помощью точечной записи
console.log(myCity);

delete myCity.country; // Удаление свойств с объекта с помощью оператора delete и точечной записи
console.log(myCity);

myCity['planet'] = 'earth'; // Добавление свойств в объект с помощью ['']
console.log(myCity);

const streetPropertyName = 'street'; // Объявление новой переменной, значение которой в последующем будет добавлено как новое свойство в объект.
// myCity.streetPropertyName = 'walk streer'; // Если добавлять свойство таким образом, то именем свойства будет не street, а streetPropertyName
// console.log(myCity);
myCity[streetPropertyName] = 'walk streer'; // Добавление нового свойства (ранее обявленной как переменная) в объект с значением. 
console.log(myCity);

// Вложенные объекты

const myCountry = {
    country: 'Ukraine',
    info: { // Вложеные объекты, тоесть все объекты которые находяться внутри объектов называються вложеными
        population: 150000,
        city: 'Kharkiv',
    }
}
console.log(myCountry.info.city); // Для доступа к вложеным свойствам необходимо дважды использовать точечну запись, сначала мы обращаемся к info, а уже после к свойству city.
console.log(myCountry);
delete myCountry.info['population']; // Удаление свойства из вложеного объекта, тут применен микс записей, а именно точечная запись на первом уровне и скобочная запись на втором, однако удаление можно выполнить и при помощи только точечной записи, а именно скобочную запись на втором уровне заменить на точечную.
console.log(myCountry);

// Использование переменных при формировании объектов

const name = 'Yaroslav';
const postsQty = 25; // Объявили переменные

const userProfile = {
    name: name, // Используем ранее объявленную переменную в роли значения для свойств объекта. В данном случае именна переменной и мена свойств совпадают, в таком случае можно использовать короткую запись, указана ниже.
    postsQty: postsQty, // В качестве свойств объекта также можно использовать любые выражения
    hasSignedAgreement: false
}
console.log(userProfile);

// Короткая запись ранее объявленных переменных в роли значения для свойств объекта. Такой формат создания объектов очень популярный в JS 
const userName = 'Yaroslav';
const userId = 20;
const userProf = {
    userName,
    userId,
    hasLastName: 'Kryvopysh'
}
console.log(userProf);

// Методы, метод - это свойство объекта, значение которого - функция (к примеру метод log() который также содержит в себе функцию).
const myStreet = {
    street: 'Heroev Truda', // это просто свойство объекта myStreet
    streetGreeting: function () { //streetGreeting - это уже метод, так как он содержит в себе функцию. //?Короткая запись данного метода будет таковой streetGreeting () и дальше идет {тело функции}.
        console.log('Greetings!!')
    }
}
myStreet.streetGreeting() // это вызов метода, таким образом мы получаем доступ к значению функции, а именно Greetings!!, что собственно видно в консоли. Тоесть в данном случае streetGreeting - это метод объекта myStreet.

// JSON - это JavaScript object notation - это формат обмена данными между компьютерами в интернете, отличие синтаксиса JSON от JS заключается в том что все свойства записываются в двойные скобки "", как и значение с типом string (строка).

const host = {
    title: 'My post',
    likesQty: 5
}

console.log(host);

JSON.stringify(host) //это метод конвертации JS данных в JSON данные
console.log(JSON.stringify(host)); // Вывод в консоль конвертирования JS в JSON. Его можно даже не записывать перед выводом, а вписать сразу в метод log.
const hostStringify = JSON.stringify(host)
console.log(hostStringify)
JSON.parse(hostStringify) //это метод конвертации JSON данных в JS данных
console.log(JSON.parse(hostStringify)) // Вывод в консоль конвертирования JSON в JS. Его можно даже не записывать перед выводом, а вписать сразу в метод log.

// Мутация в JS
// Мутации примитивнных типов переменных
const e = 10;
let g = e;
g = 30;
console.log(e);
console.log(g);
// В данном случае мы перезаписали значение g, но не изменили е, и при выводе в консоль мы получим значение е то которое мы объявили в самом начале, а именно 10. Назыв. это - //? copy by value

//Мутация объектных типов (ссылочных)
const person = {
    userName: 'Bob',
    age: 25,
    education: {
        school: 11,
        univercity: 'magistry',
    }
}
person.age = 26; // тут мы изменили свойство age объекта person, таким образом произошла мутация данного объекта, на который ссылаеться переменная person.
person.isAdult = true; //Добавили новое свойство в объект person, таким образом тоже произошла мутация данного обекта, на который ссылаеться переменная person.
//Тоесть при объявлении свойств переменной person мы получим не первоначальные их значения а мутированные, что видно в консоли.
console.log(person.age);
console.log(person);

//Мутация копий объектов
const person2 = person;// тут мы присвоили объекту person2 свойcтва объекта person, тоесть теперь объект person2 будет ссылаться на те же свойства что и объект person.
person2.age = 30; //тоесть тут мы присвоили новое значение свойству age, однако оно изменилось не только для переменной person2 но и person, таким образом мутация копии объекта привела к мутации ранее объявленного объекта с переменной person. Результат видно в консоли при последующем объявлении переменной person.
person2.sex = 'male'; // тут мы добавили новое свойство sex со значением male копии объекта, что привело к мутации и ранее объявленого объекта с переменной person.Результат видно в консоли при последующем объявлении переменной person.
console.log(person); //Таким образом видно что при мутации копии объекта, а именно объекта с переменной person2, которая скопировала свойства объекта с переменной person изменяться и свойства объекта person. Тоесть при мутации копии объекта (person2)(мутации его свойств), происходит и мутация объекта (person). Также это происходит по тому что переменная person и person2 ссылаються на один и тот же объект и имеют оба доступ к нему и могу менять свойства и значения данного объекта. - наз. это //? copy by reference (копирование по ссылке)

//Как избежать мутации объекта
//Вариант 1 - при помощи метода assign, и этот метод, являеться методом объекта Object (это глобальный объект). При помощи метода assign мы можем создавать новые объекты при этом ссылаясь на ранее объявленные. Тоесть мы создаем новый объект на основе свойств другого объекта. Ниже это видно на примере

const person3 = Object.assign({}, person)// При помощи такой записи, а именно Object.assign({}, name of object) мы скопировали свойства объекта person в свойства объекта person3, но при дальнейшем изменении свойств объекта person3 не будут меняться свойства объекта person, однако если нету вложенных объектов, тоесть при такой записи не будут мутировать только корневые свойства, а вот вложенные объекты могут мутировать, так как их ссылка не изменилась.
person3.age = 45;
person3.education.school = 9;
console.log(person3.age);
console.log(person); //как видно в консоли значение age для объекта person не изменилось, однако свойсва вложеного объекта изменились к примеру school с 11 зменилось на 9 во всех 3х объектах person, person2 и person3.

//Вариант 2 - при помощи //?оператора разделения объекта на свойства - "..." - по англ. spread.
//Запись такова:
const person4 = { ...person };
person4.userName = 'Nadya';
person4.education.univercity = 'bachalor';
console.log(person4.userName);
console.log(person.userName);
console.log(person4);
console.log(person);
//Однако такая запись нас тоже не страхует от мутации вложеных объектов, тоесть их ссылка остаеться не изменной. А вот корневые свойства как и в первом варианте перестают мутировать что видно по свойству userName.

//Вариант 3 - этот вариант позволяет избежать полной мутации объекта в том числе и вложенных объектов. Происходит это при помощи конвертации в JSON и обратно в JS.
const person5 = JSON.parse(JSON.stringify(person))//тоесть тут мы для начала перевели наш объект в объект в JSON при помощи метода stringify, после преобразовали объект JSON в объект JS при помощи метода parse, таким образом все ссылки на вложенные объекты будут разорваны.
person5.userName = 'Yaroslav';
person5.education.univercity = 'magistry';
console.log(person5);
console.log(person);
//Как видно в консоли при помощи данного способа мы полностью скопировали все свойства объекта person в person5, однако изменяя свойства объекта person5 не меняються свойства объекта person. Это происходит потому что мы полностью поменяли все ссылки данного объекта, в том числе и вложенные, тоесть все ссылки получили новый адресс (это можно сравнить с типовым проектом в строительстве, тоесть мы скопировали какой то дом и построили его в другом месте, при этом меняя копию не будет меняться оригинал, так как копия находиться по другому адрессу.)

//Функции - это  блок кода который можно выполнять многократно. Функция - это объект в JS, соответственно так как любой объект функция имеет свойства.
let h = 5;
let j = 3;
let k;

k = h + j;
console.log(k);

h = 10;
j = 15;

k = h + j;
console.log(k);
// Код выше это не функция, и данный код являеться не оптимизированным, так как в коде у насть есть повторение одинаковых блоков, а именно k=h+j; console.log(k) и такой блок мы можем поместить в функцию (что и сделано ниже) и в последующем не нужно будет повторно прописывать этот блок а просто вызивать функцию в которой находиться этот блок.

let l = 7;
let s = 3;
function sum(l, s) {//круглые скобки после имени функции могут быть пустыми, а могут содержать некий параметр, тоесть если мы этот параметр поместим в тело функции, к примеру просто через оператор сложения (+) добавим наш параметр l, s, то в консоль будет выведено результат выражения w = l + s, а также прибавление к этому результату значение l и отдельно, так как стоит оператор разделения (,) значение переменной s, в данном случае результатом функции будет 17 3 - в первом случае и 29 11 во втором. Также для объявления функции можно использовать стрелочную функцию и выглядеть это будет так //? const sum = (l, s) => {тело функции}.
    const w = l + s;
    console.log('функция sum', w);// в фигурных скобках находиться тело функции, тоесть то выражение которое должно повторяться при вызове функции, в данном случае таким выражением являеться суммирование значений переменных l и s, и последующий вывод результата такого выражения в консоль, что и видно в консоли. Таким образом в последующем меняя значение переменных l и s при вызове функции sum будет выводиться именно сложение значений этих двух переменных.
};
sum(l, s); //вызов функции
l = 9; //Присвоение новых значений переменным l и s.
s = 11;
sum(l, s);//вызов функции
//Тоесть при помощи функции мы можем избежать повторения блоков кодов так как было выше.

/*Функции могут быть:
//? - именноваными, как например функия выше имеет имя sum.
//? - присвоена переменной.
//? - анонимной, тоесть функция будет без имени, точнее она не будет иметь имени.
//? - аргументом при вызове другой функции, тоесть внутри (находиться другая функция, она будет аргументом первой)- Такие функции називаються callback.
//? - значением свойства "методом" объекта, примером этому являеться метод log который являеться функцией, ну либо же любой вложеный объект который содержит в себе функцию.
*/
const myFn = (a, b) => {
    let c
    a = a + 1
    c = a + b
    return c //данная инструкция являеться опциональной
}
console.dir(myFn); //При помощи метода dir мы можем увидить струтуру (свойства) функции, точнее свойства объекта, что будет видно в консоли.
//На примере функции выше мы рассмотрим структуру функции. Для объявленя функции можно использовать ключевое слово function, однако в данном примере использовалась стрелочная функция и ключевое слово сonst; myFn - имя функции; () - внутри содержиться аргумент (аргументом - переменные называються при вызове функции) /параметры (параметрами - переменные называються при объявлении функции) функции (параметры они же аргументы могут выступать как переменные, однако такие переменные действуют внутри функции, тоесть за пределами функции значение таких переменных будет неопределенным(undefined)). Параметров может и не быть, а может быть множество и разделяться они будут при помощи разделителя ","; {} - внутри находиться тело функции; return в данной функции являеться результатом функции, к примеру так же как и console.log('функция sum', w), //? однако очень важно return останавливает действие функции, тоесть если после return (в новой строке) будет находиться еще какое то выражение, то функция не будет его обрабатывать, так как return остановило действие функции.
// Если функция не содержит в себе инструкцию return, то функция вернет undefined.

console.log(myFn(10, 3));// Разница между параметром и аргументом хорошо видно из данного выражения, тоесть выше мы указали параметры для myFn, а именно 'a' и 'b' (они же имена переменных 'a' и 'b'), а при вызове функции myFn мы задали ей аргументы, переменной а=10, пременной b=3, а так как ранее мы в теле функции указали следующее выражение а=а+1, то есть в результате в консоли мы получим 14, так как а+1=11, b=3, a+b=11+3. К примеру параметром может быть высота и ширина, а уже аргументом может быть значение этих параметров, тоесть по простому это пара ключ и значение, только разнесенные в объявление функции (параметр - он же ключ) и вызов функции (аргумент - он же значение). таким образом параметр(высота): аргумент(100рх (значение)); Таким образом мы можем вызывать эту функцию множество раз и каждый раз задавать ей разные аргументы для уже ранее заданных параметров (к примеру высоты и ширины). Параметры для функций как и аргументы - опциональны.

//Самая короткая функция
function myFnc() { };
myFnc();

//? РАБОТА С ФУНКЦИЯМИ
//Передача значений по ссылки
const personOne = {
    name: 'Vano',
    age: 21
}
function increasePersonAge(two) {
    two.age += 1
    console.log(two);
    return two
}
increasePersonAge(personOne)
console.log(personOne.age)
/*В данном случае суть какова, что мы для функции increasePersonAge задали параметр two, которая содержит в себе некое выражение, а именно увиличение на один свойства age, ну и возврат параметра two. Далее мы вызвали функцию increasePersonAge с аргументом personOne - который являеться объектом, а значит он содержит в себе ссылку на свойства personOne, а так как при объявлении функции мы указали некое выражение то произошла непосредственно мутация свойств объекта personOne. То есть таким образом даже через функцию мы можем менять свойства объекта. Явно этого не видно, однако так как объект это ссылка на свойства и доступ к ним имеет и two и personOne то и происходит мутация первоначальных свойств, и по этому свойство age увеличилось с 21 на 22 (причем мутирует внешний объект, который за пределами функции). //! Внутри функции не рекомендуеться мутировать внешние объекты. Избежать мутирования объекта внутри функции можно при помощи создания копии объекта.*/
//Пример:
function increasePersonAgeTwo(three) {
    const updatePerson = Object.assign({},three)/* С помощью данного выражения мы объявили (updatePerson) и создали копию объекта personOne и ниже можем спокойно менять свойства данной копии (updatePerson) и при этом не будут изменены свойства первоначального объекта personOne, что видно в консоли. Но это всего лишь один из способов тех что были описаны ранее, а именно варианты избежания мутации объектов, к тому же такой способ не воспрепятствует мутированию вложенных объектов.*/
    updatePerson.age += 2
    console.log(three);//для того чтобы результат функции был виден в консоли ее нужно вызвать
    return updatePerson
}

const updatePersonOne = increasePersonAgeTwo(personOne)
console.log(personOne.age) //первоначальные свойства объекта
console.log(updatePersonOne.age)//свойства скопированого объекта

//? КОЛБЭК ФУНКЦИИ
//Колбэк-функция (или обратный вызов) - это функция, переданная в другую функцию в качестве аргумента, которая затем вызывается по завершению какого-либо действия.
//Пример
function printMyName() {//объявление новой функции
    console.log('Yaroslav')//это результат функции
}
setTimeout(printMyName, 2000)//Тут мы объявили функцию в которой находиться другая функция это и являеться колбэк функция, тоесть функция которая вызываетьтся внутри другой функции. В данном случае мы для вызова другой функции использовали глобальную функцию setTimeout, эта функция делает задержку по времени в милисекундах, тоесть функция printMyName которая выступает в роли аргумента, появиться в консоли через 2 секунды.
//Также вложенность функций может быть множественной, тоесть функция можеть быть внутри другой функции, а та может содержать в себе еще одну функцию, а та еще одну и так далее.

//? ПРАВИЛА РАБОТЫ С ФУНКЦИЯМИ
/*
1 - Называть функции исходя из выполняемых задач - тоесть чтобы было понятно что эта функция будет делать (смысловое название функций как и других переменных).
2 - Одна функция должна выполнять одну задачу, тоесть если нам необходимо выполнить сложение чисел а также работать со строками, то необходимо разделить это на две функции, одна будет работать со сложением чисел, а вторая со строками.
3 - Не рекомендуеться менять внешние относительно функции переменные (объекты), тоесть тогда когда в функцию в виде аргумента был передан объект и мы хотим его как то изменить. Если нам необходимо менять объект внутри функции то необходимо создавать копии объектов (тем или инным способом). Такой способ называеться чистая функция (pure function) - тоесть чистая функция работает только с переменными которые объявленны внутри самой функции и она не меняет внешние переменные.
*/

//? ОБЛАСТЬ ВИДИМОСТИ - определяет границы действия переменной.
//Глобальная область видимости, именно в этой глобальной области видимости определены такие переменные как global в Node.js, Window в консоле хром, globalThis во всех консолях, console и многие другие. Мы также можем создать новые переменные в глобальной области видимости, тоесть если мы просто объявим в консоли или приложении переменную, то она будет видна в глобальной области видимости.
//Локальные области видимости переменных. Переменные созданные в локальной области видимости будут видны только в локальной области видимости, за ее пределами ее не будет видно. Пример:
let r; //переменные r и t объявленны в глобальной области видимости.
let t;
function myFnct() {
    let t; //переменная t объявлення в локальной области видимости, это не та же переменная t что и была обявленна в глобальной области видимости. Такое совпадение названий переменных в локальной и глобальной области видимости допускаеться
    r = true;
    t = 10;
    console.log(t)//в данном случае переменная t объявленна в локальной области видимости.
    //Жизненный цикл переменной t, он схож на цепочку областей видимости, и логика заключаеться в том что сначала происходит проверка была ли объявленна в этой области данная переменная и если да то просходит процес поиска значения объявленной переменной t, однако за пределами локальной области поиск значения переменной t не будет происходить, так как переменная объявлена в этой локальной области и за ее пределами она не работает.
}
myFnct()
console.log(r)//переменная r будет вызвана без ошибок так как объявлена в глобальной области видимости, а значение ей было присвоено в локальной области, тоесть произойдет поиск в локальной области объявленна ли там такая переменнаяи если она не будет там найдена и не будет такого же параметра в функции, то поиск будет происходить в глобальной области видимости, а происходит это потому что функция myFnct тоже находиться в глобальной области видимости. Однако исходя из правил функций менять переменные за пределами функций запрещено, ну не то що запрещено но не желательно, во избежание такого переменные с одинаковыми именами в глобальной и локальной области видимости необходимо объявлять и в глобальной и в локальной области, таким образом переменная не будет изменена в глобальной области если мы ее переобъявим в локальной, однако это не работает с переменными в виде объектов, там необходимо использовать способы против мутации объектов. Переменные объявленные в локальной области видимости всегда имеют приоритет перед глобальной зоной видимости, тоесть сначала будет проверена локальная область а потом уже глобальная, это как с () в математике, тоесть сначала будет выполнено выражение внутри скобок, а потом уже за пределами скобок.
console.log(t) /*мы вызвали переменную t и получили тип переменной undefined, тоесть тип не определен, так как мы ей не присвоили значение в глобальной области видимости, ну и плюс как только функция myFnct отработала то она удаляет те переменные и значение которые объявлены внутри этой функции, тоесть в локальной области данных*/

const u = 100;
myFnOne = () => {
    innerFn = () => {
        console.log('function myFnOne',u)
    }
    innerFn()
}
myFnOne()//В данном случае просходит следующее, переменную u мы объявили в глобальной области видимости, однако потом объявили функцию в которой объявили еще одну функцию результатом которой являеться вывод в консоль переменной u, однако чтобы ее вызвать в консоль необходимо вызвать функцию innerFn, однако мы ее можем вызвать только в локальной области, там где мы ее и объявили, за пределами локальной области данная функция будет не видна. После чего мы вызываем функцию myFnOne в глобальной области там где она и была объявлена. Вызов переменной u будет происходить по следующей цепочке, сначала буде проведен поиск переменной u в локальной области innerFn, не найдя ее будет проведен поиск по локальной области myFnOne, не найдя значение переменной u в локальной области myFnOne, то поиск будет проведен в глобальной области видимости, и так как там и была объявлена данная переменная и присвоено ей значение, то это значение будет выведено в консоль при вызове функции myFnOne. Такой путь называеться цеппочка областей видимости.

//?ТИПЫ ОБЛАСТЕЙ ВИДИМОСТИ
/*
1 - Глобальная область выдимости;
2 - Область видимости функций;
3 - Область видимости блока - переменные объявленные с помощью let или const внутри блока имеют область видимости, ограниченную этим блоком, тоесть область ограничена {эти скобки задают область видимости блока};
*/
// необъявленные переменные
function myFnTwo() {
    a = true
    console.log(a)
}
myFnTwo()
console.log(a)
//В обоих случаях вывод в консоль не выдаст ошибку, так как автоматически а- станет глобальной переменной в глобальной области видимости //! Но так делать не рекомендуеться.

//! Правила работы с переменными
/*
1. Все переменные объявлять перед их использованием;
2. Стараться использовать const везде где это возможно, так как это уберегает от перезаписи переменных;
3. Внутри функций не изменять переменных с внешних областей видимости. Тоесть внутри функции объявлять только те функции которые будете там использовать, а если нужно вставить объект, то необходимо вставлять не сам объект, а его копию, чтобы оригинальный объект не был изменен.
*/

//? СТРОГИЙ РЕЖИМ
/*
Для того чтобы переменные не создавались автоматически в глобальной области видимости (тоесть тогда когда мы вызываем какую то переменную однако не объявив ее), то необходимо использовать СТРОГИЙ РЕЖИМ - strict mode, c ключевым словом 'use strict'. Суть этого режима в том что он более строго анализирует написанные ниже него код и запрещает автоматическое объявление переменных.
Запустить строгий режим можно с помощю 'use strict' в верху документа, таким образом весь ниже код будет анализироваться строгим режимом и будет запрещать автоматическое объявление переменных. Если этот режим включить для необъявленной переменной выше, то в консоли выдаст ошибку что такая переменная не найдена, иными словами не объявлена.
Однако не стоит слепо полагаться только на 'use strict' - а и самостоятельно следить за тем была ли объявленна та или иная переменная в документе.
Также строгий режим может быть объявлен внутри функции и таким образом он будет работать только внутри функции.
*/

//? ОПЕРАТОРЫ
/*
Операторов в JS очень много и они разделены на группы.
Оператор - это встроенная функция, тоесть эта встроенная функция запускает некий процес (к примеру матиематический расчет), а также возвращает результат (к примеру присвоение =).
Опереторы бывают:
Символьные:
- Арифметические: "+", "-", "*", "/";
- Операторы сравнения: 
    "===" - (строгое равно, тоесть он строго анализирует равны ли между собой объекти, к примеру строка '1' не являеться строго равна числу 1, и при выводе в консоль мы получим false так как они не равны строго друг другу). Тоесть он сравнивает не только значение но и тип данного значения. Пример, typeof 10 === 'number' и как результат получим true, это потому что у нас есть два операнда, первый это выражение typeof 10 - что при выводе в консоль дает строку 'number' и второй операнд строка 'number', и так как у нас значение и первого и второго операнда 'number' то и результат мы получаем true;
    "==" - не строгое равно, тоесть если в строгом равно строка '1' не будет равна строго числу 1, то при не строгом равно они будут равны и в консоли мы получим true, так как не строгое равно сравнивает только значение и не смотрит на его тип;
    "!==" - (Не равно);
    "<=" - (меньше или равно);
    ">=" - (больше или равно).
- Логические операторы: 
    "!" - логический оператор НЕ, это префиксный и унарный оператор. Данные оператор всегда возвращает значение типа Boolean (логический) в не зависимости от значения операнда, тоесть результатом будет true либо false. Оператор НЕ чаще всего используеться в условных инструкциях (к примеру таких как if и if else);
    Примеры с оператором НЕ (!):
    !10 // false, тоесть не число 10 это ложь
    !0 // true, не 0 это правда
    !'abc' // false, не строка ложь
    !'' // true, не пустая строка это правда
    !true // false
    !undefined // true
    тоесть (!) НЕ это противоположное логическое значение, тоесть (!'') - не пустая строка в логическом типе значения будет равна true.
    При двойном отрицании(!!) мы получим исходную ситуацию, тоесть (!!'') НЕ НЕ пустая строка будет false, так как первое не сделает пустую строку true а второе значение вернет первоначальное значение операнда, а именно значение нашей пустой строки. 
    Однако в отличии от пустой строки ('') пустой объект {} будет иметь значение true, а все потому что объект собственно и являеться значением в отличии от пустой строки, только это значение может содержать с себе другие значения.

    "&&" - логический оператор И - это бинарный оператор, тоесть в него два операнда, однако оператор И и ИЛИ можно объеденять в цепочку, создавая тем самым некое логическое выражение. Данный оператор возвращает значение одного из операндов, в данном случае И всегда будет возвращать операнд со значением false, если таковое будет присутствовать в выражении, если же в выражении оба операнда true или false, то будет возвращено значение последнего операнда (того что справа);
    некий трюк с оператором И:
*/
let exr = 10
exr && console.log('Выполнено!')/* в данном случае в консоль было выведено значение функции log, так как первый операнд равен значению true, тоесть суть в том что таким образом задавая аналогичное условие в реальном приложении мы можем вызывать определенные функции, к примеру если должно было произойти какое то действие которое зашито в операнд exr и оно не выполнилось, то будет выполнено другое действие либо как в нашем случае функция. Или же функция которая являеться вторым операндом должна вызываться в том или ином случае, если к примеру значение exr будет равно чему-то, и если оно равно то будет вызвана собственно нужная нам функции. И это также происходит по тому что && возвращает второй операнд если оба они равны true.*/
    
/*    
    "||" - логический оператор ИЛИ - это бинарный оператор, тоесть у него два операнда, однако оператор И и ИЛИ можно объеденять в цепочку, создавая тем самым некое логическое выражение. Данный оператор возвращает значение одного из операндов, в данном случае ИЛИ всегда будет возвращать операнд со значением true, если таковое будет присутствовать в выражении. Однако если значение обоих операндов будет true, то вернется результат первого операнда, а не второго.

    Операторы && и || являються операторами короткого замыкания, так как если говорить про оператор && то он будет искать первое ложное выражение, и если в первом операнде такое выражение будет найдено, то проверка второго даже не будет проводиться и нам сразу выдаст результат первого выражения. 
    Такая же ситуация и с ||, только он будет искать первое правдивое выражение и опять же если такое будет найдено в первом операнде, то второе не будет проверяться вообще.

    Цепочка операторов && и ||:
    a && b && c && d - в данном случае проверка будет происходить по цепочке, сначала а, потом b, потом c, потом d, и как только будет найдено первое ложное значение, все последующие операнды не будут проверяться. Однако если все операнды будут правдивы или же ложны, то вернеться значение последнего операнда, а именно d;
    a || b || c || d- тут такая же ситуация, проверка будет происходить по цепочке, сначала а, потом b, потом c, потом d, и как только будет найдено первое правдивое значение, все последующие операнды не будут проверяться. Однако если все операнды будут правдивы, то вернеться значение первого операнда, а именно a, если же все будут false то значение будет undefined;

    Ложные значения, те значения которые при приведении к логическому типу будут выдавать значение false, к ним относять, значение "false", "0"(0 как число), пустая строка '' (та строка которая не содержит в себе ничего, даже пробел будет делать строку не пустой), undefined, и значение null. 
    
- Оператор присвоения: "=".
    а=10 ("а" и "10" это операнды либо же аргументы)
    Так как оператор это встроенная функция, то последовательность работы и структура этой функции будет выглядеть так:
    function =(переменная, выражение){
    1. Получение результата выражения
    2. Поиск переменной по имени
    3. Присвоение результата выражения
    4. Возврат результата выражения
    }
    тоесть грубо говоря "=" - это имя данной функции.

- Оператор разделения: ",".

- Оператор разделения объекта на свойства - "..."
пример:
*/

const button = {// тоесть тут мы объявили объект button и задали ему некие свойства такие как width со значением в 200 пикселей и свойство текст со значением 'Buy'. В конце в табличной форме мы вывели все это в консоль.
    width: 200,
    text: 'Buy'
}
console.table(button)
const redButton = {//а тут к примеру мы поняли что нам нужна такая же кнопка только с дополнительными свойствами, к примеру красная, по этому мы создали новуй объект redButton, а далее при помощи оператора разделения объекта на свойства "..." сослались на предыдущий объект, тоесть скопировали его свойства и далее к скопированым свойствам добавили свойство color со значением 'red'. В конце результат вывели в консоль в табличной форме. Мы также можем изменить и существующее свойство скопированого объекта, на примере указанно изменение значения свойства text. К тому же, при такой записи, а именно через разделитель объекта на свойства, мы сделали копию объекта, однако при измнении копии, мутация оригинала не будет проиходить (даже если в объекте присутствует вложенные обекты, при попытке так сделать выдает ошибку.).
    ...button, // оператор разделения объекта на свойства, с помощью него мы сделали копию объекта button
    color: 'red', //тут мы добавили новое свойство которого нету в оригинальном объекте
    text: 'No Buy' // а здесь мы изменили имеющееся в оригинальном объекте свойство и при этом свойство в оригинальном объекте не изменились, изменилось оно только в копии, сто видно при выводе в консоль оригинала после копии.
}
console.table(redButton)
console.table(button)

// Также при помощи оператора разделения объекта на свойства "...", можна объединять свойства разных объектов, как видно на примере ниже:

const buttonTwo = { //Тут мы создали еще один объект с некими свойствами.
    height: 200,
    info: 'info'
}
const buttonMain = {//А здесь мы создали объект в котором хотим объеденить свойства неких других объектов, чтобы на основе их свойств были сформированы свойства данного объекта.
    ...button, // тут мы через оператор разделения свойств объекта добавили свойства объекта button
    ...buttonTwo // а тут мы через оператор разделения свойств объекта добавили свойства объекта buttonTwo
}
console.table(buttonMain)//так как оба оператора разделения находяться в теле нашего объекта buttonMain то и произошло их объединение. Также при таком объединении важен порядок, так как если оба объекта будут иметь одинаковые свойства, то они перезапишуться в пользу последнего, тоесть если button и buttonTwo имеют одно и тоже свойство то при объединении присвоиться свойство со значением именно объекта buttonTwo так как оно стоит последним.

/*Текстовые операторы:
- typeof - с его помощью можно проверить тип того или иного значения.
- instanceof  - с его помощью можно проверить принадлежность объекта тому или инному классу.
- new - с его помощью можно создать новый экземпляр того или инного объекта который уже существует в JS по умолчанию - это по сути класс и тип.
- delete - с помощу данного оператора можно удалить переменную либо же ее свойство просто записав это следующим образом delete myFnc.age таким образом мы удалим конкретно свойство age.
УНАРНЫЕ ОПЕРАТОРЫ:
У унарных операторов всего один операнд или аргумент. Примеры:
    а++; +а; delete obj.a (delete-это оператор, obj.a - это операнд); typeof a; new Object().
БИНАРНЫЕ ОПЕРАТОРЫ:
У бинарных операторов всегда два операнда или аргумента. Примеры: 
    а = 5; а + b; a += 5; a === b; a && b;

ФОРМАТЫ ЗАПИСИ ОПЕРАТОРОВ:
Инфиксная запись, то есть при такой записи оператор будет находиться между операндов. Пример: а = true; a + b; a += 5 и так далее, тоесть если оператор находиться между операндов, то это инфиксная запись.
Префиксная запись, в ней оператор находиться перед операндом, Пример: ++а, typeof a, delete obj.a. typeof и delete пишиться только в префиксной записи, если использовать иную форму, то оператор не сработает.
Постфиксная запись, тоесть такой оператор записываеться после операнда, Пример: а++, myFunction () - скобки этот тоже оператор. Постфиксные операторы тоже пишуться в строгом порядке, тоесть сначала операнд, а потом оператор, если изменить порядок, оператор не будет работать или же получиться совсем иной результат.

ПРИОРИТЕТНОСТТЬ ЗАПИСИ ОПЕРАТОРОВ 
(есть в интернете целая табличка в которой показана приоритетность всех операторов).
К примеру:
'a + b * c / d - e' - при такой записи приоритетность будет как в математике, тоесть сначала умножение и деление, а уже потом сложение и вычитание, однако приоритетность можно изменить к примеру также как и в математике при помощи (скобок), с чего видно что оператор() имеет более высокий приоритет нежели просто арифметические операторы, тоже применимо и к остальным операторам, тоесть сначала будет выполнено выражение в скобках, а уже после за пределами этих скобок.
*/

const abcd = !!{}
console.log(abcd)

//КАНКАТЕНАЦИЯ СТРОК
/*
Канкатенация строк - иными словами объединение, осуществляеться при помощи оператора (+), с ее помощью можно складывать как значение непосредственно так и сами переменные, однако в любом случае результатом канкатенации (сложения) будет сложение значений, к примеру:
*/

const afs = 'Hello'
const fas = 'world'
console.log('Hello ' + 'world')//это канкатенация непосредственно значений, однако так пости никто не делает.
console.log(afs + ' ' + fas) // тут проведена канкатенация переменных.
//Также можно создать и новую переменную значением которой будет канкатенация двох предыдущих переменных, что и сделано в примере:
const sfa = afs + ' ' + fas
console.log(sfa)
/*
Однако такой тип канкатенации не совсем удобен, так как нужно постоянно следить за тем где ставить пробел, либо же другие знаки припинания.
В связи с чем в JS есть шаблонные строки (template string literal), такая канкатенация записываеться в темплейт строке ``, а само выражение в фигурных скобках {внутри них можно исрользовать любые выражения} перед которыми установлен знак $, таким образом можно осуществить канкатенацию любых выражений, даже тех которые не являються строками, а к примеру функциями и тогда мы сможем выводить некий интерактивный контент который будет взаимодействовать с пользователями (тоесть есть шаблонная заготовка, к примеру "Привет" а у же при помощи функции к нему будет подставленно определенное значение, или даже целое выражение). Ниже пример шаблонной строки:
*/

const greeting = `${afs} ${fas}`//Шаблонная строка, она же template string.
console.log(greeting)

const myName = 'Yaroslav'
const whereFrom = 'Kharkiv'
const myInfo = `${'My namy is'} ${myName}, ${'I from'} ${whereFrom}`//Беря таким образом значение переменной myInfo в темплейт строку и помещая необходимые выражения в ${} то мы можем имитировать написание обычного текста, что и показано тут, тоесть мы ставим пробелы запъятые и прочие знаки припенания между ${этих блоков}.
console.log(myInfo)
/*
Однако при этом необходимо не забывать какой тип у переменных, так как если мы сделаем канкатенацию строки и числа то в итоге мы получим строку, а не число и строку, тоесть число 10 станет строкой '10'. По этому необходимо помнить какие типы мы хотим канкатенировать и что должно выйти в итоге.
*/

/*
ФУНКЦИОНАЛЬНЫЕ ВЫРАЖЕНИЯ:
Функциональные выражения всегда анонимны, так как не имеют имени.
Ниже отличие объявления функции и функционального выражения.
*/
function fnMy(a, b) {//это объявленная функция, так как она имеет имя, и такую функцию можно использовать автономно, тоесть где угодно, при этом необходимо всего лишь вызвать такую функцию
    let c
    a = 25
    b = 35
    c = a + b
    return c
}
//--------------------------------
//!При создании анонимной функции выдает ошибку, пока не понял до конца почему, так как в курсе об этом не упоминаеться и не говориться о том что может возникнуть ошибка.
const fn = function (a, b) {// это (измененная функция так как анонмная выдает ошибку) анонимная функция и она не имеет имени, а также ее не возможно использовать автономно, однако анонимная функция может быть аргументом другой функции, тоесть быть колбэк функцией. И такая функция чаще всего и используеться как аргумент в других функциях, тоесть как колбэек функция.
    let c
    a = 25
    b = 35
    c = a + b
    return c
}
    
// однако при создании анонимной функции возникает ошибка, и решить ее можно как вариант при помощи объявления переменой а далее присвоение ей вот этой анонимной функции.
(function () {// это анонимная функция и она не имеет имени, а также ее не возможно использовать автономно, однако анонимная функция может быть аргументом другой функции, тоесть быть колбэк функцией. И такая функция чаще всего и используеться как аргумент в других функциях, тоесть как колбэек функция.
    let c
    a = 25
    b = 35
    c = a + b
    return c
})
//--------------------------------
// Итог, вывести анонимную функцию можно только как колбэк, но при этом она должна иметь выражение в теле функции и определенный результат ее работы, так как это показано ниже
setTimeout(function () {
    console.log("Отложенное сообщение!")
}, 1000)

//? СТРЕЛОЧНЫЕ ФУНКЦИИ

/* 
Стрелочная функция - это выражение. Стрелочные функции всегда анонимны, тоесть они похожи на функциональное выражение.
Она имеет другой синтаксис нежели обычная функция, а именно "function "имя функции" (параметры функции) {тело функции, некое выражение и собственно результат этого выражения(который являеться опциональным, эго может и не быть если это не требуется)}" - это обычная именная функция.Стрелочная же функция выглядит так "имя переменной" = (параметры функции) => {тело функции, некое выражение и собственно результат этого выражения(который являеться опциональным, эго может и не быть если это не требуется) }, => - это спец синтаксис, он как раз и делает ее стрелочной. У стрелочной функции нету ключевого слова function его заменяет "=>". Имени у стрелочной функции может не быть, это может быть анонимная функция, однако если это анонимная функция то она можеть быть только как колбэк.
*/

const myArrowFn = () => {// это стрелочная функция
    console.log('Стрелочная функция')
}
myArrowFn()//Хотя мы и вызываем функцию именно в этом месте однако результат этой функции находиться на строке где console.log, что хорошо видно в консоли, и сколько раз мы ее бы не вызывали результат будет ссылатся на всё ту же строку. и это так со всеми функциями, не только со стрелочными.

function myArrowFnTwo() { // это стандартная объявленная функция
    console.log('Стрелочная функция -2')
}
myArrowFnTwo()

setTimeout(() => {
    console.log("Отложенное сообщение при помощи колбэк функции выполненной в виде стрелочной функции!")
},1000)// запись стрелочной функции без имени как колбэк функция.
/*
Стрелочная функция более предпочтительна еще потому что когда мы ей присваиваем имя при помощи переменной использую для объявления ключевое слово const таким образом мы обезопасиваем себя от создания функций с таким же именем, это же касаеться и функциональных выражение где мы тоже присваиваем им имя через переменную.

Сокращенный вариант записи стрелочной функции.
Вариант 1: Если у нее только один параметр до (скобки) можно опустить, и выглядеть это будет так:
a => {
    тело функции
}, однако такая запись менее читабельна, и предпочтительнее все же таки ставить скобки().
Вариант 2: Если тело функции содержит только одно выражение, и выглядит это так:
(a, b) => a + b - и в таком случае стрелочная функция неявно возвращает результат выражения, этот вариант записи очень популярен //!Однако нужно понять почему не работает, однако если ей дать имя то все будет работать
*/
/*
ЗНАЧЕНИЕ ПАРАМЕТРОВ ФУНКЦИЙ ПО УМОЛЧАНИЮ
Пример:
*/
function myltByFactor(value, multiplier = 1) {// тоесть тут мы задали опредененные параметры, а в теле функции указали некое выражение, а именно value умножить на multiplier, а при вызове мы ей задали аргумент, тоесть значение ранее указанным параметрам, таким образом функция прочитала аргумент и подставила его в выражение и как рузультат мы получили 20 и 5 в консоли, так как в первом случае мы указали 10 и 2 =20 при умножении и во втором случае 5, а 5*1=5 (но тут момент мы параметру multiplier задали сразу дефолтное значение, что видно при объявлении функции, если его изменить то и результат будет другим, тоесть мы его можем как задавать так и не задавать, а присваивать только как аргумент - оно еще назыветься значение параметра по умолчанию).
    console.log(value*multiplier)//только для вывода в консоль
    return value*multiplier
}
myltByFactor(10, 2)
myltByFactor(5)

const myltByFactorArrow = (value, multiplier = 1) => {
    console.log(value*multiplier)
    return value*multiplier
}
myltByFactorArrow(7,3)
/*
Значения параметров функций по умолчанию.
Пример:
*/
const newPost = (post, addedAt = Date()) => ({/* тут мы используем неявный возврат объекта, и для этого нам необходимо перед фигурными скобками {} поставить круглые скобки (), так как если мы их не поставим то функция указанное выражение прочтет как тело функции, которое в данном случае не являеться. Тоесть значение Date будет вычесляться именно в момент вызова функции*/
    ...post,/*с помощью оператора разделения объекта на свойства мы добавляем в объект post новое свойство(на объекте пост не стоит зацикливаться, он может быть и не объявлен, ниже мы просто объявим новый объект и добавим в него свойство addedAt, однако это может быть и реально объявленный объект)*/
    addedAt,/*это короткая запись так как имя параметра и свойства совпадают. И после создания такого объекта мы можем его сохранять в базе данных и тогда в базе данных мы будем иметь данные о том когда был создан данный объект newPost*/
})

const firstPost = {
    id: 1,
    author: 'Yaroslav',
}

newPost(firstPost)// Тут еще важно что второй аргумент отсутствует, оно указанно выше как параметр и имеет дефолтное значение, однако это дефолтное значение являеться динамическим, а не статичеким, и в зависимости от того когда будет вызвана данная функция будет меняться и дефолтное значение (вместо даты может быть и другое динамическое значение). Также именно при вызове этой функции объекту firstPost будет и присвоено допольнительное свойство addedAt которое являеться и параметром, причем с дефолтным значением.
console.table(newPost(firstPost))
//!Домашка
/*
Ниже приведен явный возврат объекта при помощи return, тоесть мы записали стандартный синтаксис стрелочной функции, далее в теле функции создали новый объект внутри которого через оператор разделителя свойств объекта добавили в объект post новое свойство addedAt. Далее после закрытия объекта используя инструкцию return мы возвращаем в функцию наш новосозданный объект myPost.
*/
const newPostTwo = (post, addedAt = Date()) => {
    const myPost = {// объявление нового объекта в котором мы с помощью разделителя свойств объекта добавим в объект post новое свойство addedAt.
        ...post,
        addedAt,
    }
    return myPost
}
//ниже все тоже что и при неявном возврате объекта в функции.
const firstPostTwo = {
    id: 1,
    author: 'Yaroslav',
}

newPost(firstPostTwo)
console.table(newPost(firstPostTwo))

//Обработка ошибок
/*
При возникновении ошибок в JS, весь код который находиться после ошибки не будет обработан, тоесть процес обработки будет остановлен. что ниже видно в примере.
*/

const fnWithError = () => {
    throw new Error ('Some error')
}
// fnWithError() /*//!Здесь мы заблокировали ошибку чтобы код работал дальше, однако ниже показан пример где с помощью кода мы ловим эту ошибку и блокируем ее, чтобы она не препятствовала дальнейшей обработке кода*/
console.log('Continue...') //этот вывод в консоль не произведен так как мы выше вызвали функцию с ошибкой которая остановила обработку кода дальше.
/*
Как бороться с непоймаными ошибками в JS. Решением непойманых ошибок решаеться при помощи специального синтаксиса try и catch, который состоит из двух блоков кода.
*/
try {
    //сюда помещаеться код в котором вероятно возникнет ошибка
} catch (error){
    //этот блок выполняеться если была найдена ошибка в блоке try, тоесть блок try находит ошибку, а catch ее ловит и не весь код а именно та часть где она появилась. В дальнейшем мы можем такой код вынести за пределы проекта и обработать его при необходимости.
}
//Ниже приведен результат работы try/catch где мы ловим возникшую в коде ошибку:
const fnWithErrorTwo = () => {//здесь мы объявили функцию
    throw new Error ('Some error')
}
try {//сюда мы помещаем код который будет якобы искать нашу ошибку
    fnWithErrorTwo()
} catch (error) {//здесь ошибка error присвоена как значение переменной error, которая заключена в ()
    console.error(error)// здесь мы при помощи метода error в консоли мы выводим в консоль саму ошибку как объект, где указанно, что это за ошибка и где она возникла, на какой строке кода.
    console.log(error.message)//здесь мы в консоль выводим только сообщение ошибки, а не всю ошибку как показано выше
}
console.log('Continue two...')
/*
? Ремомендуеться все блоки кода которые могут содержать ошибку заключать try/catch блоки, чтобы при возникновении ошибки приложение или весь код не обрушивался и не переставал работать, а именно обрабатывать код который находиться под ошибкой.
*/

//ИНСТРУКЦИИ
/*
Выражение - всегда возвращает значение, например присваивание переменной значения это выражение (а=5 - это веражение которое вернет значение 5).

Инструкция, примером инструкции являеться объявление переменной при помощи ключевого слова let (let a - это инструкция). Инструкция выполняет определенные действия.

Выражение-инструкция, тоесть выражение может быть инструкцией - что и следует из названия (по англ это expression statement).
*/
//Пример инструкции

let ab; //Это инструкция которая выполняет следующее действие, она объявляет переменную а и присваивает ей значение undefined(значение не определено) и собственно возвращает присвоеное значение.

const ba = 5; //Это также инструкция и она делает теже действия что и первая, только тут мы переменной присваиваем некое значение, а именно 5 и далее эта инструкция возвращает нам присвоеное значение.

if (ab > ba) {//if и if else это тоже инструкция, однако она выполняет только действие и не возвращает нам значение. Все что {это блок кода как и в функции} и этот блок кода будет выполнен если указанное выражение в () - будет правдиво, тоесть если ab>ba.
    console.log('a is lager');
}

for (let i = 0; i++; i < 5){//это тоже инструкция, которая имеет некое условие в () и блок кода в {}, только в этом случае блок кода будет повторяться до тех пор пока условие не достигнет результата false, после чего цикл остановитья
    console.log(i);
}
//Инструкция обычно заканчиваеться ";" таким образом мы можем отличить где у нас инструкция, а где простое выражение. Исключением являеться то что после блока кода с инструкцией не требуеться ";" тоесть после {} мы не ставим ";". Однако ";" можно опускать в JS, это не являеться ошибкой.

// Выражение - инструкция, примеры:
'abc';//мы записали выражение, после чего поставили ";", что говорит нам о том что это инструкция. В данном случае такая инструкция не имеет смысла, однако по такому же принципу создана инструкция 'use strict' (строгий режим) - который являеться инструкцией.
a = a + 3;// все что до ";" выражение, и если бы ";" небыло то оно так и осталось бы выражением, однако как только мы поставили ";" и запишем это выражение на отдельной строке оно станет инструкцией, в данном случае стало.
//Как отличить выражение от выражения-инструкции, если там нету ";", если выражение написано с новой строки то - это выражение-инструкция. По мимо этого выражения могут быть использованы как аргументы в вызовах функции, а вот инструкции не могут. Пример:
function myFnInst(a) {
    console.log(a);//это инстркуция так как стоит ";"
}
const da = true;//это инстркуция так как стоит ";", но все что до ";" - это выражение.
let sa = 10;//это инстркуция так как стоит ";", но все что до ";" - это выражение.
myFnInst(2 + 3)// здесь мы указали некий аргумент в виде выражения и как результат параметра а будет 5, что видно в консоли.
myFnInst(da)// здесь мы передали в качестве аргумента переменную da, и в консоль будет выведено значение этой переменной а именно true, что видно в консоли.
myFnInst(sa = sa + 1)//здесь мы тоже в качестве аргумента для функции передали некое выражение, и результатом данного выражения мы получим присвоение переменной sa - результат сложения старого значение переменной sa +1, и в итоге получим 11, что видно в консоли.
//!myFnInst(sa = sa + 1;)/*Тут мы попытались в роли аргумента передать инструкцию, а именно выражение на конце которого ";" однако получили ошибку, так как в функцию нельзя передать в качестве аргумента инструкцию*/
//!myFnInst(let sa) /* Здесь мы тоже попытались передать инструкцию, а мы знаем что let это инструкция как и ";" и мы также получили ошибку так как инструкцию передать в ролу аргумента нельзя*/
const bf = 10;
const myFnBf = (a) => {
    console.log(a)
}
//myFnBf(bf = 10;) - даже в стрелочных функциях при попытке передать в роли аргумента инструкцию, мы получим ошибку, так как это нельзя делать.
//!Инструкция не может быть трансформированна в выражение

//?МАССИВЫ
/*
В первую очередь массив - это объект. Массив - это объект с цифровыми именами свойств, инными словами свойства у массива называються очень просто - 0, 1, 2, 3, 4, и так далее (в зависимости от количества элементов в массиве), тоесть имена свойства у массива - это цифры. Массив - это очень популярная конструкция в JS.
*/
//Формат записи массивов
const myArray = [1, 2, 3]//Здесь мы создали массив, отличие от объекта тут в том что свойства указанны в [квадратных скобках - они же элементы] а не {фигурных скобках}
console.log(myArray)
// В один массив вожно добавлять элементы разных типов, а именно строки, числа, булевые значения, объекты, другие мыссивы, не имеет значения. Тоесть массивы в JS могут сохранять абсолютно разные значения. В указанном примере выше все значения это тип число.
//Второй вариант создания массива путъем создания нового экземпляра класса Array (он определяеться как класс так как первое слово написано с заглавной, это основной признак класса) и при помощи ключевого слова new можно создавать новые экземпляры классов. Запись такого варианта создания массива выглядит так:
const myArray2 = new Array(1, 2, 3)// Второй способ создания массивов через ключевое слово new и класса Array (с англ - множество, инными словами массив каких то значений или объектов в реальной жизни). Тут мы вызываем функцию Array аргументами которой являються элементы массива, в нашем случае это 1,2,3.
console.log(myArray2)
/*
На первый взгляд кажется что массив myArray и myArray2 одинаковы, однако это не так, они схожы однако не одинаковы, а суть этого заключаеться в том что массыв - это объект, а объект - это ссылка, тоесть объект ссылаеться на какие то свойства и значения. По этому массив myArray и myArray2 будут имметь разные ссылки (данные храняться в разных местах памяти), даже если содержащиеся в них элементы абсолютно одинаковы.

Структура массива это посути объект со свойствами которые имеют цифровое название, о чем упоминалось ранее. Также есть служебное свойство которое содержит информацию о длинне массива в элементах. Стоит отметить что название свойств массива начинаеться не с 1, а с 0.

Суть еще в чем, что в массиве у нас нету пар ключ: значение, тоесть мы их не указываем так как в объекте, так как массив автоматически каждому элементу присваивает ключ, он же имя элемента (а именно 0, 1, 2, 3 и так далее). Все это свойства к которым мы можем обратиться при помощи точечной записи или же скобочной записи[], к примеру мы можем обратиться к свойству length. JS - самостоятельно в автоматическом режиме отвечает за актуальность свойства length, тоесть нам не нужно ни создавать это свойство и присваивать ему какое то значение, ни менять это значение JS делает это автоматически.
*/

//Массив с разными типами элементов
const myArray3 = [1, true, 'Yaroslav']
console.log(myArray3)
console.log(myArray3.length)//Здесь мы при помощи точечной записи "." обратились к свойству length, однако это не работает с числовыми свойствами массива и для того чтобы обратиться к конкретному свойству, после имени массива необходимо поставить [и тут вписываем свойство к которому мы хотим обратиться] - тоже самое касаеться и объектов которые имеют свойство имя которого число любое, при попытке обратиться к такому свойству при помощи точечной записи выдаст ошибку.

const myArray4 = [1, true, 'Yaroslav']
console.log(myArray4[2])//при помощи [] мы обратились к конкретному свойству и вывели его значение, и так как отсчет ведеться от 0, то свойство 2 это строка 'Yaroslav'.

myArray3 === myArray4// мы получим false, так как они оба ссылаються на разные места в памьяти.

/*
Однако если мы создадим новую переменную myArray5 и присвоим им значение к примеру массива myArray3, и потом попытаемся их сравнить то получим true, так как теперь myArray5 ссылаеться на тоже место в памьяти что и myArray3, логика такая же как и с объектами.

Порядок элементов в массиве важен, однако он автоматический, и он всегда начинаеться с 0.

При помощи [] мы можем не только вызывать конкретный элемент но и менять его значение, пример ниже:
*/

myArray4[1] = 'Vano'// Здесь мы при помощи [] именили значение элемента 1.
myArray4[3] = undefined//Здесь мы при помощи [] добавили новый элемент и присвоили эму значение.
console.log(myArray4)

//?Методы массивов - они же функции высшего порядка в массивах (методами прототипов или функциями прототипов)
//Метод Push
/*
При помощи метода Push мы можем добавить новый элемент в массив, однако суть такова что нам уже не нужно указывать порядковый индекс этого элемента так как это указанно выше, тоесть метод Push автоматически добавляет новый элемент в конец массива. Вызвать метод Push можно при помощи точечной записи. Пример ниже:
*/
myArray4.push(true) //Тут мы добавили с помощью метода Push новый элемент в массив используя точечную запись. В скобках (значение) мы указываем значение добавленого элемента.
console.log(myArray4)
/*
Для удаления элемента с массива, а именно последнего необходимо применить метод pop используя все ту же точечную запись, однако в () мы не указываем никаких аргументов, так как он удаляет последний элемент, и аргументы тут не нужны. Пример ниже:
*/
myArray4.pop()//Здесь мы при помощи метода pop удалили последний элементс с массива, а именно true тот который мы добавили при помощи метода push.
console.log(myArray4)

//Возврат последнего элемента с массива при помощи метода pop.
const removedElement = myArray4.pop()//тут мы создаем новую переменную и присваиваем массив с методом pop, тоесть при это наша новая переменная removedElement получит последнее удаленное значение с массива, но при этом же метод pop удаляет еще один элемент с массива
console.log(myArray4)
console.log(removedElement)// в данном случае мы получим undefined так как последним удаленным элементом и был как раз таки undefined.

//Метод unshift - добавляет элемент в начале массива
myArray4.unshift('abc')// Тут мы добавили новый элемент в начало массива при помощи метода unshift и точечной записи. Однако метод unshift используеться достаточно редко, чаще всего используеться push.
console.log(myArray4)

//Метод shift - удаляет первый элемент из списка
myArray4.shift()// Тут мы удалили первый элемент из списка при помощи метода shift и точечной записи, тоесть мы удалили добавленный выше элемент со значением 'abc'.
console.log(myArray4)
//По аналогии с методом pop, метод shift может возвращать удаленный элемент, однако также как и pop не в массив, а как значение для новосозданной переменной, пример ниже:
const removedElementTwo = myArray4.shift()//тут мы создали новую переменную и присвоили ей значение в виде удаленного элемента, а именно число 1, тоесть мы одновременно и удалили элемент с массива и присвоили его новосозданной переменной
console.log(myArray4)
console.log(removedElementTwo)//результат число 1, так как это тот элемент который мы удалили.
/*
Однако следует не забывать что методы pop, push, unshift и shift мутируют оригинальный массив(изменяют оригинальный массив), тоесть они не создают новый массив, а мутируют (изменяют) старый.
*/

/*
Очень популярный метод массива forEach.
Пишется этот метод в camelCase нотации, тоесть for с маленькой, а Each с заглавной forEach. Аргументом метода forEach являеться функция, популярной являеться стрелочная функция, именнованную функцию нету смысла создавать так как это будет колбэк функция.

Метод forEach перебирает весь массив и с каждым элементом данного массива проводит определенные действия которые мы заложили в колбэк функцию. Тоесть на примере ниже мы в колбэк функции указали параметр el (название не имеет значение, назвать можно этот параметр как угодно) далее результатом этой функции будет вывод в консоль выражения el*2, и в качестве значения (аргумента) колбэк функции будет выступать весь массив, таким образом функция будет повторяться пока не пройдеться по всем элементам массива и не выполнит с ними указанное выражение.

Метод forEach перебирает массив, тоесть проводит с каждым элементом определенные действия, в независимости от их типа, однако если посмотреть какой тип возвращает метод forEach то это будет undefined тоесть не определенные. Итак метод forEach ничего не должен по этому он и не содержит в себе инструкции return.
*/
myArray.forEach(el => console.log(el * 2)) //в колбєк функции el => console.log(el * 2) мы использовали короткую запись, так как она содержит только один параметр, а если параметр всего один, то (el) можно не писать. Также так как тело функции содержит только одно выражение то {} скобки можно опустить, что собственно тут и сделано, тоесть мы сделали неявный возврат, однако это роли не играет. Тут мы собственно видим результат, тоесть каждое значение массива было умножено на 2 (мы сослались на массив который содержит числа 1,2,3 и как результат получили 2,4,6, если сослаться на массив где значением другой тип данных то мы получим NaN специальную математическую ошибку).
console.log(myArray)//Здесь мы видим что метод forEach не изменил оригинальный массив.

/*
Популярный метод массива map
Этот метод очень часто использует в React.
Метод map по своей логике очень схож с методом forEach, он тоже перебирает массив и выполняет с ним некое действие которое указанно в колбэк функции, однако основное отличие между ними, это то что map создает абсолютно новый массив и уже все действия производяться с новым массивом. Пример ниже:
*/
const newArray = myArray.map(el => el * 3)//Тут мы создали новую переменную newArray и присвоили ей результат работы метода map, а именно сделали копию массива myArray и непосредственно уже с этой копией выполнили указанное в колбэк функции действие, далее так же как и в методе forEach мы указываем параметр и делаем неявный возврат, по этому использовалась короткая запись. И в данном случае действием этой колбэк функции будет перебор каждого значения массива и умножение его на 3, по этому в результате мы получим новый массив уже со значениями которые умножены на 3.
console.log(newArray)
console.log(myArray)
//Метод map с явным возвратом
const newArrayTwo = myArray.map((el) => {
    return el * 3//В данном примере мы в функции вернули все скобки как для аргументов так и для тела функции, а также добавили инструкцию return, так как без нее для каждого элемента массива вернется undefined, потому что такая функия без ключевого слова return ничего не возвращает, соответственно возвратом ничего для каждого элемента массива будет undefined.
})

//Задачка с массивом от Андрюхи
// Условие: Необходимо перебрать массив, таким образом чтобы там остались только значения с типом number, дальше после перебора массива, необходимо каждый элемент возвести в степень и результат вывести в консоль.
const arr = [1, 3, '4', null, undefined, '55', 100, 3, false, null, undefined, '101', 1102]

if (arrT = arr.filter((n) => { //мой вариант решения перебора массива и вывод результата в консоль
    return typeof n === 'number'
})) {
    arrT.forEach((el) => {
    console.log(Math.pow(el, 2))
    })
}

console.log(arr.filter((element) => typeof element === 'number').map((element) => Math.pow(element, 2)))// короткий вариант решения от Андрюхи с неявным возвратом

console.log(arr.filter((element) => { //тот же вариант что и у Андрюхи только с явным возвратом
    return typeof element === 'number'
})
    .map((element) => {
        return Math.pow(element, 2)
    })
)

//? ДЕСТРУКТУРИЗАЦИЯ ОБЪЕКТОВ
/*
Деструктурирующее присваивание – это специальный синтаксис, который позволяет нам «распаковать» массивы или объекты в кучу переменных, так как иногда они более удобны. Деструктуризация также прекрасно работает со сложными функциями, которые имеют много параметров, значений по умолчанию и так далее.
*/
// Не деструктуризированный объект
const userProfileTwo = {
    nameUs: 'Kryvopysh',
    commentsQty: 23,
    hasSignedAgreement: false,
}
//Деструктуризированный объект. Тоесть пр помощи ниже записанного синтаксиса можно одновременно объявить новую переменную и присвоить ей значение на основе значений свойств объекта. При деструктуризации объектов используються {} скобки.
const { nameUs, commentsQty } = userProfileTwo//тут мы при помощи синтаксиса деструктуризации объекта создаем две новые переменные на снове свойств объекта userProfileTwo, а именно nameUs и commentsQty, тоесть при помощи данного синтаксиса мы скопировали свойство и значение объекта userProfileTwo и создали из них переменные, где имя свойства (ключ) nameUs - становиться именем переменной, а значение свойства, становиться значением переменной.
const { hasSignedAgreement } = userProfileTwo// Тут тоже что и выше. По сути все три переменные можно было объявить одновременно, но для примера они разделены, чтобы было понятно, что можно таким образом создать как одну переменную так и сразу несколько в одном выражении как например в первом варианте.

console.log(nameUs)
console.log(commentsQty)

//?ДЕСТРУКТУРИЗАЦИЯ МАССИВОВ
//По сути синтаксис деструктуризации массивов очень схож с деструктуризацией объектов, ну а суть деструктуризации такая же, только уже на основании свойств (элементов) массива создать новые переменные. При деструктуризации массивой используються [] скобки.Также отличием являеться имена переменных, если в объектах именами переменных стали именна свойств, то в массивах их можно задавать самостоятьльно, тоесть не 0,1,2,3 и тд, а задавать к примеру fruitOne, fruitTwo и тд., и присвоение будет идти от 0 и далее, тоесть, элемент с индексом 0 и значением 'banana' будет присвоено первому по порядку имени, тоесть fruitOne, второй элемент массива с индексом 1 fruitTwo и так далее, при этом названия могут и не содержать никаких числовых значений, просто присвоение будет происходить по порядку от 0 и до последнего индекса в массиве.

const fruits = ['Apple', 'Banana', 'Mango']
const [fruitOne, fruitTwo, fruitThree] = fruits//как видно в консоли то значения присвоились переменным по порядку, тоесть элемент со значением - Apple под индексом 0 переменной fruitOne, элементу со значением - Banana под индексом 1 переменной fruitTwo, и элементу со значением - Mango под индексом 2 переменной fruitThree. Все из за того что порядок следования в массивах очень важен, грубо говоря он строгий.

console.log(fruitThree)
console.log(fruitTwo)

//?ДЕСТРУКТУРИЗАЦИИЯ ФУНКЦИЙ
//Ниже проведем деструктуризацию функции на основании ранее объявленного объекта

const userInfo = ({ nameUs, commentsQty }) => {//вся деструктуризация вписана в {} как параметр функции, а дальше по стандарту синтаксис стрелочной функции и тело функции.
    if (!commentsQty) {//функция if только для того чтобы задать тело функции, по сути тут может быть что угодно, но так более наглядно видно как происходит деструктуризация. Тут мы задали аргумент функии, если свойство commentsQty не имеент значения, а точнее оно равно false что собственно сответсвует условию НЕcommentsQty, тоесть значение false, в консоль будет возвращен первый return, если же commentsQty содержит значение больше 0 то будет возвращен второй return.
        return `User ${nameUs} has no comments`
    }
    return `User ${nameUs} has ${commentsQty} comments`
}

console.log(userInfo(userProfileTwo))//Здесь мы вызвали функциию которая содержит в себе объект, точнее ссылку на свойства объекта, это для того чтобы наша функция смогла вытащить с объекта деструктурированные свойства, а именно nameUs и commentsQty

//Деструктуризация объекта внутри функции:

const userInfoTwo = (profile) => {
    const { nameUs, commentsQty } = userProfileTwo
    console.log(nameUs, commentsQty)
}
userInfoTwo()

//? УСЛОВНЫЕ ИНСТРУКЦИИ
/*
В JS есть такие условные инструкции как if, if else, switch, Тернарный оператор.
Инструкции в JS выполняют определенные действия. 
Инструкции нельзя использовать в качестве аргументов, соответственно указанные инструкции нельзя использовать в качестве аргумента в другой функции.
*/

//Инструкция if - начинаеться с зарезервированого слова if, далее идет условие, которое помещено в () скобки, и далее {}, внутри фигурных скобок находиться блок кода который выполняеться однократно если условие правдиво. Все что в {} - это блок инструкции. Условие может быть задано абсолютно любое. Условие это собственно некое выражение которое возвращает значение. Если значение условия - ложно (null, undefined, false) то блок инструкции не будет выполнен. Тоесть в условии результат приводиться всегда к булевому значению true или false. Ниже простой пример:

let val = 10 //мы объявили переменную которая равна 10
if (val > 5) {//в () мы задали условие, тоесть если значение val больше 5, то к val должно быть прибавлено 20
    val +=20 //тут как раз таки прибавление val + 20 если значение условия true.
}
console.log(val)//так как условие правдиво, то в консоли мы получим 30 (10+20), однако если условие будет ложно то в консоль нам вернеться первоначальное значение val, а именно 10, тоесть инструкция if не выполнилась.

//Другой пример
const person6 = {
    age: 30
}
if (!person.name) {//тут мы использовали оператор не (!), тоесть если объект person не содержит свойство name, или же это свойство name не имеет значение, то в консоль будет выведено некое сообщение, которое указанно в блоке инструкции. И такая запись условия очень популярная в JS с использованием оперетора (!).
    console.log('Имя пользователя не указанно!')
}

//Инструкция if else - принцип такой же как и у инструкции if, только в if else два блока кода, соответственно можно задать сразу две инструкции, первая будет выполнена если условие правдиво, а вторая инструкция (второй блок кода) если условие ложно.
//Пример:
let val2 = 15
if (val2 > 10) {//тут мы в () задали условие
    val2*=2//этот блок будет выполнен если условие правдиво, тоесть если 15 больше 10, то переменная val2 со значением 15 должна бить умножена на 2.
} else {
    val2/=2 //эта часть блока будет выполнена если условие неправдиво и 15 меньше 10, то переменная val2 со значением 15 должна бить разделена на 2.
}
console.log(val2)

//Инструкция if else if - главное отличие от if и if else - это то что можно создавать длинную цепочку из условий, так как первое if задает условие а первый блок кода будет выполнен если условие правдиво, если же нет, то вступает в силу второе else if со своим условием, и блок кода будет выполнен если условие правдиво, если нет то будет выполнено последнее else блок которого будет выполнен если все условия выше ложны, таким образом можно создать длинную цепочку из условий.
//Пример:

const ageUser = 25

if (ageUser > 18) {//тоесть если возраст юзера будет больше 18 то выведет в консоль сообщение Is Adult, если же условие не правдиво то перейдет к выполенину следующего
    console.log('Is Adult')
} else if (ageUser >= 12) { // и если это условие будет правдиво то выведет сообщение Is teenager
    console.log('Is teenager')
} else { //если оба условия ложны то будет выполнена последняя инструкция
    console.log('Is child')
}
//Также данную инструкцию можно выполнить и только при помощи интсрукции if. Пример ниже:

if (ageUser >= 18) {//тоесть если возраст юзера будет больше 18 то выведет в консоль сообщение Is Adult, если же условие не правдиво то перейдет к выполенину следующего
    console.log('Is Adult')
}
if (ageUser >= 12&&ageUser < 18 ) { // и если это условие будет правдиво то выведет сообщение Is teenager. Оператор И тут указан для того чтобы ageUser находился в диапазоне между 12 и 18, и в консоль не выводилось два значения.
    console.log('Is teenager')
}
if (ageUser < 12) { //если оба первых условия ложны то будет выполнена последняя инструкция
    console.log('Is child')
}

//?ИСПОЛЬЗОВАНИЕ ИНСТРУКЦИЙ if В ФУНКЦИЯХ
//При помощи инструкций в функциях можно тоже создавать некую цепочку из логических условий. Пример:

const sumOfPositiveNumber = (cv, vc) => {
    if (typeof cv !== 'number'|| typeof vc !=='number') {
        return 'One of the arguments is not a number'
    }
    if (cv <= 0 || vc <= 0) {
        return 'Numbers are not positive'
    }
    return cv+vc
}
console.log(sumOfPositiveNumber(10, 5))

//? ИНСТРУКЦИЯ SWITCH
//Инструкция switch это альтернатива инструкции if else if, тоесть эта инсрукция применяеться когда нам необходмо задать несколько условий, ниже пример:

const month = 2

switch (month) {//В () мы указываем выражене, в данном случае это переменная коорая содержит некое значение.
    case 12://тут указанно некое значение и логика какова, выражение которое указанно в () проверяеться на строгое равенство (===) каждому из кейсов, точнее если case со значением 12 строго равно выраженю month то будет выполнен код ниже, до первого ключевого слова break (оно останавливает обработку кода ниже если условие по равенству выполнено). если же условие по равенству не выполнено, то будет обработан следующий кейс, если и там равенство не будет выполнено, то пойдет обработка следующего по порядку кейса. Если же ни один из кейсов, не отвечает строгому равенству то будет выполнен вариант default, однако default не объязателен, его может и не быть.
        console.log('December')
        break// если не указать break то инструкция продолжит выполнение и будут проанализованы следующие кейсы.
    case 1:
        console.log('January')
        break
    case 2:
        console.log('February')
        break
    default:
        console.log('It is not a winter month')
}

//?ТЕРНАРНЫЙ ОПЕРАТОР
/*
У тернарного оператора 3 операднда. Конструкция с тернарным оператором - это выражение (а выражение возвращает значение). Запись тернарного оператора УСЛОВИЕ ? ВЫРАЖЕНИЕ-1 : ВЫРАЖЕНИЕ-2 - знак ? и : - это часть синтаксиса тернарного оператора. Таким образом результатом такого выражения как тернарный оператор это будет результат выражения-1 или выражения-2 в зависимости от условий. На месте условия также может быть любое выражение. Если условие правдиво, то вернется результат выражения-1, если же условие ложно то вернется результат выражения-2. Главный нюанс тернарного оператора - в инструкции, тоесть на месте выражения-1 и 2 может быть только выражение, туда невозможно вставить инструкцию так как в if else. Также инструкцию с тернарным оператором рекомендуеться писать на трех разных строках, по примеру:
Условие
? Выражение 1
: Выражение 2
*/
const valueTwo = 11

valueTwo
    ? console.log('The condition is true')// В данном случае тернарный оператор выведет это сообщение, так как выражение правдиво, тоесть если бы у нас valueTwo было бы равно значению undefined, null, пустая строка, 0 то тогда вывелось бы сообщение второе, так как перечисленные значения будут равны false.
    : console.log('The condition is false')

// Пример 2

const value1 = 10
const value2 = 20
const myFunction1 = () => { }


value1 && value2//так как обе переменные содержат значение то они правдивы, а оператор И вернет true
    ? console.log(myFunction1(value1, value2))//тут просто для примера показанно, что здесь может быть и вызов функции, так как вызов функция это выражение, console.log для вывода в консоль. Также нужно не забывать что console.log всегда возвращает undefined - по этому он и отобразиться в консоли
    : console.log(myFunction2())

//Пример где тернарный оператор выступает в качестве аргумента для функции, в нашем случае console.log
const value3 = 13
console.log(value3 >= 0 ? value3 : -value3)//здесь тернарный оператор выступает в роли аргумента функции

// еще один пример
const value4 = -5
const res = value4 >= 0 ? value4 : -value4 // тут мы новой переменной присвоили результат тернарного оператора. Такой способ использования тернарного оператора тоже очень популярен.
console.log(res)

//? ЦИКЛЫ
/*
Для чего нужны циклы - для удобства перебора объектов, массивов, это позволяет убрать множество повторяющихся частей кода для перебора.
Все циклы - это инструкции. Циклы можно использовать для перебора массива, однако это не рекомендуеться, лучше использовать методы (функции высшего порядка массивов) forEach map reduce и другие.
*/
//? Цикл for
// Синтаксис цикла for состоит из зарезервированного слова for, далее в () скобках указываються три инструкции, а именно (Начальная инструкция; условие; Иттерационное действие), после идет блок кода в {} и этот блок кода будет выполняться на каждой итерации, покуда условие не достигнет значения false, после этого иттерация прекращаеться, а собственно прекращаеться и сам цикл. Пример:

for (i = 0; i < 5; i++) {//Здесь мы задали цикл со следующим условием, первоначально наша переменная "i" = 0, однако нам необходимо чтобы вывелось в консоль такое количество значений которые будут отвечать true заданному условию, тоесть "i" должна быть меньше 5, и в конце мы задали шаг итерации в данном случае инкримент, тоесть при повторении цикла значение "i" должно увеличиваться на 1 до тех пор пока значение "i" будет меньше 5.
    console.log(i)
}

//Пример спользования цикла for для перебора массивов:
const myArray6 = ['First', 'Second', 'Third']//Создали новый массив
for (i = 0; i < myArray6.length; i++){//Задали инструкции для перебора массивы, условием которого являеться длинна массива, тоесть массив будет перебираться до тех пор пока не переберет весь массив, так как значение длинны массива всегда больше за последний индекс элемента массива (так как индексы начинают отсчет от 0, а значение длинны с 1)
    console.log(myArray6[i])
}

//Ниже такой же перебор массива, только при помощи функции высшего порядка массивов, а именно forEach. Однако используя данный метод, то у нас будет доступ не только к элементам массива, но и к индексам массиваю.
const myArray7 = ['First', 'Second', 'Third']
myArray7.forEach((element, index)=> {// Тут мы вывели и сам элемент и индекс, однако можем вывести и только что то одно
    console.log(element, index)
})

//? ЦИКЛ WHILE
//Цикл while повторяеться до тех пор пока условие будет правдиво, если условие сразу будет ложно то цикл даже не начнеться, но необходимо избегать моментов когда условие будет всегда правдиво, иначе цикл будет повторяться до бесконечности, пока браузер не умрет. По сути это тот же цикл for, особых отличий кроме записи пока не увидел.

let ii = 0//Использовали тут Лет так как при использовании конст необходимо значение переменной задавать сразу в той же строке, при попытке присвоить той же переменной новое значение в другой строке то выдаст ошибку.
while (ii < 5) {
    console.log(ii)
    ii++//если этой инструкции не будет, то цикл будет выполняться бесконечно
}

//? ЦИКЛ DO WHILE
//Можно сказать что это тоже что и while, только в отличии от while будет выполено хотя бы один цикл.
//Пример:
let iai = 0
do {
    console.log(iai)//тоесть тут будет выведено первое значение которое не будет проверяться на правдивость условия, таким образом наша переменная попадет в цикл только после изменения, а именно прибавления ей единице.
    iai++
} while (iai < 5)

//? Цикл for in
//Используеться для перебора объекта а именно свойств объекта, ниже пример. С помощю данной инструкции можно выполнять разные действия с каждым свойством объекта

const myObject = {
    x: 10,
    y: true,
    z: 'abc'
}
for (const key in myObject) {//здесь мы объявили цикл for in, однако ключевое слово in помещено в () скобки, так же в скобках мы объявили переменную key и сослались на объект myObject. key представляет каждое свойство в объекте. Все что в {} это блок инструкции которая выполняеться для каждого свойсва
    console.log(key, myObject[key])//Здесь первое key это имя свойства а второе это непосредственно значение данного свойства
}

//Также подобный перебор можно осуществить при помощи метода forEach и метода Object.keys, пример ниже:
Object.keys(myObject).forEach(key => {//Тоесть тут мы использовали сначала метод глобального объекта Object, а именно метод keys и сослались в () на объект который мы будем перебирать и далее вызвали метод forEach где получили ключи от объекта в виде массива.
    console.log(key,myObject[key])
})

//Также такой перебор можно осуществить при помощи метода values того же глобального объекта Object и метода forEach. Однако тут мы перебрали объект и получили доступ непосредственно к значениям

Object.values(myObject).forEach(value => {
    console.log(value)
})

//?for in цикл для массивов
const myArray8 = [true, 10, 'abc', null]
for (const key2 in myArray8) {
    console.log(myArray8[key2])
}// Но так делать не рекомендуеться для этого у массивов есть специальные методы для перебора массивов.

//? Цикл for of
//Он появился в ECMAscript 2015. Iterable в данном цикле - это любое значение либо переменная которая содержит значение по которому можно итерироваться, тоесть элементы которого можно перебирать, к примеру в любой строке можно перебирать символы - такая строка называеться итерированной, Element же будет представлять конкретный символ в строке, тоесть это будет переменная которая доступна внутри каждой итерации в цикле. Пример:

const myString = 'Hey'//здесь мы перебрали все символы строки
for (const letter of myString) {
    console.log(letter)
}

//for of для массивов
for (const element of myArray8) {//здесь мы перебрали все элементы массива.
    console.log(element)
}//Однако опять же лучше всего для массивов использовать forEach
//При помощи for of не возможно проитерировать объект, так как объекты не итерируються в JS, при попытке так проитерировать объект мы получим ошибку что объект не возможно проитерировать. Если нужно проитерировать объект, то нужно использовать for in или же преобразовать объект в массив а уже потом его итерировать.

//?МОДУЛИ
/*
Модули позволяют структурировать код. Также модули позволяют избегать дублирования кода.
export and import - появился в ES6. Состоит он из ключевых слов export и import.
Для того чтобы импорт и экспорт коректно отображались в консоли браузера, то необходимо в html файл добавить к тегу <script type = "module"> тип модуль, после чего браузер перестанет выдавать ошибку, в виде примера в этой же папке создано 2 js файла и html файл, в одном из жс создано функцию, и сделано экспорт (function.js), в  другом сделано импорт этой функции и сделан вызов этой функции. Помимо этого как и написано выше в html в тег <script> добавлено type = "module". 
Как пишет учебник, то можно делать именной экспорт и дефолтный (по умолчанию), однако дефолтный можно использовать всего раз в документе, и лучще его использовать для экспорта классов, во всех остальных случаях лучше использовать именной экспорт. Что касается импорта, то можно импортировать части кода как по отдельности, к примеру какой тот один объект, функция, массив так и к прмеру все объекты в том или ином файле при помощи as (как)(более подробно об этом смотреть в учебнике), однако общий импорт всех объектов не рекомендуеться, так как он плохо влияет на оптимизацию кода, а так же на читабельность кода. По этому лучше всего использовать поодночный импорт. Также при помощи as можно переименовать переменные которые мы импортируем (в указанных выше файлах пример по импорту с перейменованием).
Для примера в этих же файлах создано еще несколько функций.
?Правила работы с модулями:
- Модули должны быть одноцелевыми, тоесть один блок кода один модуль, к примеру выполнение какой то функции или какого то действия, тем самым мы делаем код более читабельным и структурированым. Ну и плюс это дает возможность эту часть кода использовать многократно, что собственно облегчает весь код.
- Располагать все экспорт инструкции внизу файла, это делает код более читабельным, тоесть расположив все экспорты внизу сразу видно что именно заэкспортировано, есть вариант делать экспорт и там где объявляем какую то часть кода, переменную, функцию и так далее, однако если модуль большой по объему то нужно будет детально просматривать весь модуль на предмет того что заэкспортировано а что нет, и это трудоемкий процесс. Если экспортов много то рекомендуеться их записывать с новой строки, так как в примере.
- Весь Импорт же необходимо располагать в самом верху файла, это также связано с читабельностью кода и удобством работы с ним. Также если есть внешние модули, то рекомендуеться их располагать в саммом верху, а уже после них импорт собственных модулей.
- По возможности работать с export default - однако пока не понятно в чем его фишка, тоесть основная суть его что один модуль одна задача, тоесть один какой то экспорт (одна функция, переменная и тд.).
*/

//? Классы и прототипы
/*
Синтаксис class появился в жс в ES6. В этом синтаксисе можно создавать классы используя ключевое слово class. 
Классы позволяют создавать прототипы для объектов. А на основании прототипов создаються экземпляры. 
Переменная this указывает на конкретный экземпляр класса.
Для создания нового экземпляра класса необходимо использовать ключевое слово new.
*/

class Comment {
    constructor(text) {
        this.text = text
        this.votesQty = 0
    }
    upvote() {
        this.votesQty += 1
    }
    static mergeComments(first, second) {
        return `${first} ${second}`
    }
}

const firstComment = new Comment('First comment')
console.log(firstComment)
firstComment.upvote()
console.log(firstComment)
firstComment.upvote()
console.log(firstComment)
firstComment.upvote()
console.log(firstComment)
firstComment.upvote()
console.log(firstComment)

const secondComment = new Comment('Second comment')
console.log(secondComment)
secondComment.upvote()
console.log(secondComment)
Comment.mergeComments('First comment', 'Second comment')
console.log(Comment.mergeComments)

/*
Статические методы. Создаються статические методы при помощи ключевого слова static перед названием метода (Выше это указанно в примере).
*/

class NumbersArray extends Array {
    sum() {
        return this.reduce((el, acc) => acc += el, 0)
    }
}

const myArrayNum = new NumbersArray(2, 5, 7)
console.log(myArrayNum)
myArrayNum.sum()
console.log(myArrayNum.sum())

console.log(Comment.prototype === firstComment.__proto__)

/*
?Промисы
Промисы позволяют обрабатывать отложенные во времени события. У промисов 3 состояния, это ожидание, исполнен, отклонен. Промис это объект.
*/

fetch('https://jsonplaceholder.typicode.com/todos')
    .then(response => {
        console.log(response)
        return response.json()
    })
    .then(json => console.log(json))
    .catch(error => console.error(error))

// Встроеная функция fetch
const getData = (url) =>
    new Promise((resolve, reject) => 
        fetch(url)
            .then(response => response.json())
            .then(json => resolve(json))
            .catch(error=>reject(error))
    )
getData('https://jsonplaceholder.typicode.com/todos/10')
    .then(data => console.log(data))
    .catch(error => console.log(error.message))

//? ASYNC/AWAIT - это специальный синтаксис для упрощения работы с промисами. Она же асинхронная функция. С ключевым словом function, async ставиться спереду (префиксная унарная форма), в других же функциях, к примеру в стрелочной идет приравнивание переменной функции async и указывается перед параметрами стрелочной функции (перед ()). Асинхронная функция всегда возвращает промис

const myAsync = async () => {
    return 'Success!'
}
console.log(myAsync())
myAsync()
.then(value=>console.log(value))
// AWAIT - с помощью данного ключевого слова можно ожидать можно ожидать результат другого промиса, и результат может быть не один, тоесть несколько таких эвейтов.

const timerPromise = () => new Promise((resolve, reject) => setTimeout(() => resolve(), 2000))
const asyncFn = async () => {
    console.log('Timer starts')
    const startTime = performance.now()
    await timerPromise()
    const endTime = performance.now()
    console.log('Timer ended', endTime-startTime)
}

asyncFn()

//? ASYNC/AWAIT - это синтаксическая надстройка над промисами. 2. AWAIT возможен только внутри асинхронной функции. 3. ASYNC функция всегда возвращает промис. 4. ASYNC функция ожидает результата инструкции AWAIT и не выполняет последующие инструкции.

const getDataTwo = async (url) => {
    const res = await fetch(url)
    const json = await res.json()
    return json
}
const url = 'https://jsonplaceholder.typicode.com/todos/10'

try {
    const dataTwo = async() => await getDataTwo(url)
    console.log(dataTwo)
} catch (error) {
    console.log(error.message)
}

getDataTwo()