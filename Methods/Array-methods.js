/*
!! Методы массивов
Методы массивов - они же функции высшего порядка в массивах (методами прототипов или функциями прототипов)
*/
//Массив для работы c примерами:
const array = [
    {userName: 'Ivan', age: 2, addInfo: 'dog', breed: 'Italian greyhound'},
    {userName: 'Jeck', age: 5, addInfo: 'dog', breed: 'Beagle'},
    {userName: 'Bob', age: 3, addInfo: 'dog', breed: 'Greyhound'},
    {userName: 'Chip', age: 1, addInfo: 'dog', breed: 'Teckel'},
];
console.log(array);

const arrayTwo = [1, '25', 'for', 100, null, '55', 30,];
console.log(arrayTwo);

const people = [
    { name: 'Yaroslav', age: 30, budget: 50000 },
    { name: 'Nadya', age: 35, budget: 45000 },
    { name: 'Vano', age: 2, budget: 5000 },
    { name: 'John', age: 25, budget: 2000 },
    { name: 'Elena', age: 15, budget: 15000 },
    { name: 'Anna', age: 40, budget: 1500 },
];
console.log(people)

const numberArr = [-2, 5, 15, -10, 25, 8];

const user = { name: 'Yaroslav', age: 30, budget: 50000 };

/*----------------------------------------------------------------------------------*/
/*
!! ДОБАВЛЕНИЕ/УДАЛЕНИЕ ЭЛЕМЕНТОВ
!! Метод Push
При помощи метода Push мы можем добавить новый элемент в массив, однако суть такова что нам уже не нужно указывать порядковый индекс этого элемента, так как метод Push автоматически добавляет новый элемент в конец массива. Вызвать метод Push можно при помощи точечной записи. 
Синтаксис записи следующий:
??  array.push('добавляемое значение') - тоесть здесь при помощи точечной записи и метода Push мы добавляем в массив array 'новое значение' в конец массива.
*/
// arrayTwo.push(true)

/*----------------------------------------------------------------------------------*/

/*
!! Метод Рор
Для удаления элемента с массива, а именно последнего необходимо применить метод pop используя все ту же точечную запись, однако в () мы не указываем никаких аргументов, так как он удаляет последний элемент, и аргументы тут не нужны.
Синтаксис записи следующий:
?? array.pop() - при помощи такой записи можно удалить последний элемент из массива.
*/
// arrayTwo.pop();
/*
Помимо этого при помощи метода рор можно создать переменную значением которой будет удаленный элемент из массива, а именно последний.
Синтаксис записи следующий:
*/
// const removedElement = arrayTwo.pop();
// console.log(removedElement);

/*----------------------------------------------------------------------------------*/

/*
!! Метод unshift
Данный метод добавляет элемент в начале массива. Синтаксис все тот же, а именно точечная запись.
?? array.unshift('добавляемое значение')
*/
// arrayTwo.unshift('Yaroslav');

/*----------------------------------------------------------------------------------*/

/*
!! Метод shift
Метод shift удаляет первый элемент из списка.
?? array.shift()
Также как и метод рор, одновременно с удалением элемента, его значение можно присвоить новой переменной.
*/
// const removedElement = arrayTwo.shift();
// console.log(removedElement);

/*----------------------------------------------------------------------------------*/

/*
!! Метод splice
Метод arr.splice(str) – это универсальный «швейцарский нож» для работы с массивами. Умеет всё: добавлять, удалять и заменять элементы.
Его синтаксис:
?? array.splice(индекс с которого начать удалять/заменять элементы, количество элементов которые необходимо удалить/заменить)
?? arr.splice(index, deleteCount, elem1, ..., elemN)
Причем данные действия можно выполнять одновременно, а именно, одновременно удалять элементы с массива и добавлять в него новые.
Помимо этого данный метод позволяет также просто добавлять элементы без удаления, для этого вместо deleteCount необходимо поставить 0, тоесть если в примере ниже вместо 1 поставить 0, то с массива ничего не будет удалено, а просто добавлено два новых элемента.
Также удаленные значения можно присваивать переменной, как и в двух других методах по удалению элементов с массива.
Допускаеться использовать отрицательное значения индекса, тоесть если мы вместо 0 поставим -1, а вместо 1, 0, то новые элементы будут вставленны в конец массива перед последним элементом, тоесть -1 указывает на отступ с конца, тоесть отступить на 1 элемент с конца и вставить туда данные.
*/
// arrayTwo.splice(0, 1, 'с нулевого индекса удалили один элемент', 'добавили этот и прошлый элемент');

/*
!Однако следует не забывать что методы pop, push, unshift, shift и splice мутируют оригинальный массив(изменяют оригинальный массив), тоесть они не создают новый массив, а мутируют (изменяют) старый.
*/

/*----------------------------------------------------------------------------------*/

/*
!! Метод slice
Метод slice - возвращает новый массив, в который копирует элементы, начиная с индекса start и до end (не включая end). Оба индекса start и end могут быть отрицательными. В таком случае отсчёт будет осуществляться с конца массива.
Если в примере оставить только одно значение и ему присвоить отрицательный индекс, то копирование начнется с конца с казанного индекса, тоесть если поставить только -2, то скопируються элементы насиная от второго с конца, тоесть последние два элемента.
Можно вызвать slice и вообще без аргументов: arr.slice() создаёт копию массива arr. Это часто используют, чтобы создать копию массива для дальнейших преобразований, которые не должны менять исходный массив.
Синтаксис записи следующий:
?? arr.slice(start, end)
*/
// const arraySlice = arrayTwo.slice(0, 2);
// console.log(arraySlice);

/*----------------------------------------------------------------------------------*/

/*
!! Метод concat
Метод arr.concat создаёт новый массив, в который копирует данные из других массивов и дополнительные значения.
?? arr.concat(arg1, arg2...)
Он принимает любое количество аргументов, которые могут быть как массивами, так и простыми значениями.
В результате мы получаем новый массив, включающий в себя элементы из arr, а также arg1, arg2 и так далее…
Если аргумент argN – массив, то все его элементы копируются. Иначе скопируется сам аргумент.
Обычно он копирует только элементы из массивов. Другие объекты, даже если они выглядят как массивы, добавляются как есть,что и видно в примере, так как один массив array содержит в себе обьекты, собственно так они и скопировались в новый массив.
*/
// const arrayConcat = arrayTwo.concat(['добавили это', 'и добавили это'], array);
// console.log(arrayConcat);

/*----------------------------------------------------------------------------------*/
/*
!! МЕТОДЫ ДЛЯ ПЕРЕБОРА МАССИВА

!! Метод forEach
Очень популярный метод массива forEach.
Пишется этот метод в camelCase нотации, тоесть for с маленькой, а Each с заглавной forEach. Аргументом метода forEach являеться функция, популярной являеться стрелочная функция, именнованную функцию нету смысла создавать так как это будет колбэк функция.

Метод forEach перебирает весь массив и с каждым элементом данного массива проводит определенные действия которые мы заложили в колбэк функцию. Тоесть на примере ниже мы в колбэк функции указали параметр el (название не имеет значение, назвать можно этот параметр как угодно) далее результатом этой функции будет вывод в консоль выражения el*2, и в качестве значения (аргумента) колбэк функции будет выступать весь массив, таким образом функция будет повторяться пока не пройдеться по всем элементам массива и не выполнит с ними указанное выражение.

Метод forEach перебирает массив, тоесть проводит с каждым элементом определенные действия, в независимости от их типа, однако если посмотреть какой тип возвращает метод forEach то это будет undefined тоесть не определенные. Итак метод forEach ничего не должен по этому он и не содержит в себе инструкции return.
Синтаксис:
? arr.forEach(function(item, index, array) {делать что-то с item});
тоесть item - это каждый элемент массива;
index - это индекс того или инного элемента (item);
array - собственно сам массив по которому осуществляется проход.
Однако не все параметры должны или могут быть переданы в колбек функцию, может быть передан к примеру только один параметр item, если это необходимо или нет необходимости прописывать остальные параметры. За частую последние два параметра очень редко используются, в основном используеться только параметр item, что существенно сокращает запись.

Ниже forEach - c применением стандартной анонимной функцией с применением ключевого слова function, однако поскольку функция содержит всего один параметр и одно выражение в теле функции, то используя стрелочную функциию код можно значительно сократить.
*/
// people.forEach(function (person) {
//     console.log(person);
// });

/*
Сокращенная запись метода с использованием стрелочной функции. Когда у нас всего один параметр и одно выражение в теле функции, то предпочтительнее использовать именно такую запись. Также предпочтительно использовать именно стрелочную функцию в качестве колбек функции.
*/
// people.forEach(person => console.log(person));

/*----------------------------------------------------------------------------------*/
/*
!! МЕТОДЫ ДЛЯ ПРЕОБРАЗОВАНИЯ МАССИВА:

!! Метод map
Популярный метод массива map
Этот метод очень часто использует в React.
Метод map по своей логике очень схож с методом forEach, он тоже перебирает массив и выполняет с ним некое действие которое указанно в колбэк функции, однако основное отличие между ними, это то что map создает абсолютно новый массив и уже все действия производяться с новым массивом.
Синтаксис:
? const newArray = arr.map(function( currentValue, index, array) {return 'Возвращает элемент для new_array'});
Тоесть мы можем заменить нужные нам данные в массиве, или же вывести только конкретные данные, также можем провести некое сложение данных, и это все будет проделано непосредственно с новым массивом, исходный массив останеться без изменений.
Если мы возвращаем более одного выражения, то необходимо использовать ключевое слово return.
*/
/* Ниже замена значений в массиве, тоесть мы все значения в массиве, а именно все обьекты заменили на слово Hello.*/
// const newPeople = people.map(person =>  {return 'Hello'});
// console.log(newPeople);

/* Ниже вывод конкретного значение каждого элемента, тоесть был создан новый массив, но уже только с необходимыми нам данными, как пример только имена пользователей*/
// const newPeople = people.map(person => {
//     return person.name;
// })
// console.log(newPeople);

/* Ниже еще один пример обработки данных при помощи метода map*/
// const newPeople = people.map(person => {
//     return `${person.name}, (${person.age})`;
// })
// console.log(newPeople);

/* Также пример выше можно записать используя короткую запись, так как мы возвращаем только одно выражение return, то само ключевое слово return мы можем убрать и оставить только саму шаблонную (темплейт строку), и так как мы убрали ключевое слово, то и скобки мы тоже можем убрать. Результат будет абсолютно такой же. Именно такой вариант записи являеться более предпочтительным. */
// const newPeople = people.map(person => `${person.name}, (${person.age})`);
// console.log(newPeople);

/* Также мы можем проводить и другие действия с данными, к примеру математические вычесления. Ниже мы получили новвый массив с данными, где конкретные значения исходного массива были умножены на 3*/
// const newPeople = people.map(person => person.age * 3);
// console.log(newPeople);

/*Еще один пример работи с методом map, здесь ми при помощи данного метода создали новый массив перебрав исходний и умножив в нем каждое число на 3.*/
// const multBy = numberArr.map((i) => { return i * 3 });
// console.log('Массив с числами:', numberArr);
// console.log('Новый массив с числами где каждое число в массиве умножено на 3:', multBy);


/*Здесь же мы провели аналогичные действия по умножению и перебору массива, однако теперь это универсальная функция по умножению, куда в аргументы можно подставить любой другой массив и число на которое будет умножено каждое число массива.*/
// const fnMultBy = (arr, n) => {
//     return arr.map((i) => {
//         return i * n;
//     });
// };
// console.log('Универсальная функция для умножения:', fnMultBy(numberArr, 3));


/*----------------------------------------------------------------------------------*/

/*
!! Метод reduce
Метод reduce() применяет функцию reducer к каждому элементу массива (слева-направо), возвращая одно результирующее значение.
Методы arr.reduce и arr.reduceRight похожи на методы map и forEach, но они немного сложнее. Они используются для вычисления какого-нибудь единого значения на основе всего массива.
Синтаксис:
? const value = arr.reduce(function(previousValue, item, index, array) { }, [initial]);
Функция применяется по очереди ко всем элементам массива и «переносит» свой результат на следующий вызов.
Аргументы:
previousValue – результат предыдущего вызова этой функции, равен initial при первом вызове (если передан initial),
item – очередной элемент массива,
index – его индекс,
array – сам массив.
? array.reduce((total, element)=>{}, 0);
0 в конце, это точка отсчета, тоесть если мы говорим о сумме значений то вписав вместо 0, к примеру 100, то в результате мы получем сумму значений проитерированного массива +100. 
Инными словами метод reduce позволяет получить одно финальное значение, к примеру у нас есть итоговая стоимость затрат по каждому обьекту, а метод reduce при итерации массива сложит все значения в воедино, таким образом мы получим итоговое значение, тоесть сумму затрат по всему обьекту.
*/
/* Ниже мы проитерировали массив и в результате чего мы получили новый массив, где прошлись по каждому элементу массива, нашли там необходимые данные, в нашем случае ключ budget, и сумму значений ключа budget поместили в total. Так как мы в теле функции возвращаем только одно выражение, то мы можем сократить запись, убрав скобки, а также ключевое слово return*/
// const amount = people.reduce((total, person) => {
//     return total + person.budget;
// }, 0);
// console.log(amount);

/*Ниже короткая запись. Такая запись тоже являеться более предпочтительной, так как существенно сокращает код*/
// const amount = people.reduce((total, person) => total + person.budget, 0);
// console.log(amount);

/* Помимо сложения метод reduce может выполнять и другие функции, к примеру возврат найбольшего числа*/
// const theBigestNumber = numberArr.reduce((bigest, number) => {
//     if (bigest < number) {
//         bigest = number;
//     }
//     return bigest;
// });
// console.log('Выводим массив с числами:', numberArr);
// console.log('Выводим самое большое число из массива с числами при помощи reduce:', theBigestNumber);

/*
!! Метож sort
Метод sort() на месте сортирует элементы массива и возвращает отсортированный массив. Сортировка не обязательно устойчива (англ.). Порядок сортировки по умолчанию соответствует порядку кодовых точек Unicode.
Синтаксис
? arr.sort([compareFunction])
Параметры - compareFunction необязательный параметр. Указывает функцию, определяющую порядок сортировки. Если опущен, массив сортируется в соответствии со значениями кодовых точек каждого символа Unicode, полученных путём преобразования каждого элемента в строку. Однако метод sort изменяет исходный массив, как видно ниже массив отсортировался однако при этом изменил исходный массив.
Если функция сравнения compareFunction не предоставляется, элементы сортируются путём преобразования их в строки и сравнения строк в порядке следования кодовых точек Unicode. Например, слово "Вишня" идёт перед словом "бананы". При числовой сортировке, 9 идёт перед 80, но поскольку числа преобразуются в строки, то "80" идёт перед "9" в соответствии с порядком в Unicode.
Чтобы использовать наш собственный порядок сортировки, нам нужно предоставить функцию в качестве аргумента arr.sort().
Функция должна для пары значений возвращать:
? function compare(a, b) {
?   if (a > b) return 1; // если первое значение больше второго
?   if (a == b) return 0; // если равны
?   if (a < b) return -1; // если первое значение меньше второго
? }
*/
// const sortArr = arrayTwo.sort();
// console.log(sortArr);
// console.log(arrayTwo);

/* Пример сортировки по числовому порядку. Здесь в качестве параметра для метода сортировки указана колбек функция, параметрами которой являються переменные а и b, а в теле указано виражение*/
// console.log(arrayTwo.sort((a, b) => a - b));

/*----------------------------------------------------------------------------------*/
/*
!! МЕТОДЫ ДЛЯ ПОИСКА СРЕДИ ЭЛЕМЕНТОВ МАССИВА

!! Метод filter
Метод filter() создаёт новый массив со всеми элементами, прошедшими проверку, задаваемую в передаваемой функции.
Cинтаксис:
? array.filter((element, index, array) => { ... } )
Также как и в forEach, параметры index, array являются не обьязательными и могут не указываться в функции.
Метод filter() вызывает переданную функцию callback один раз для каждого элемента, присутствующего в массиве, и создаёт новый массив со всеми значениями, для которых функция callback вернула значение, которое может быть приведено к true. Функция callback вызывается только для индексов массива с уже определёнными значениями; она не вызывается для индексов, которые были удалены или которым значения никогда не присваивались. Элементы массива, не прошедшие проверку функцией callback, просто пропускаются и не включаются в новый массив.
*/
/* Ниже мы отфильтровали массив по возрасту пользователей и полученный результат был помещен в новый массив*/
// const adults = people.filter(person => {
//     if (person.age >= 18) {
//         return true;
//     }
// });
// console.log(adults);

/* Так как результатом тела колбек функции являеться возврат выполения условия, то запись можно значительно сократить, а именно убрать инструкцию if, все скобки и ключевое слово return. Ниже пример записи. Именно таков вариант записи являеться более предпочтительным.*/
// const adults = people.filter(person => person.age >= 18);
// console.log(adults);

/*----------------------------------------------------------------------------------*/

/*
!! Метод find
Метод find() возвращает значение первого найденного в массиве элемента, которое удовлетворяет условию переданному в callback функции. В противном случае возвращается undefined.
Синтаксис:
? let result = arr.find(function(item, index, array) {
?    если true - возвращается текущий элемент и перебор прерывается
?    если все итерации оказались ложными, возвращается undefined
? });
Тоесть, инными словами данный метод позволяет нам достать данные которые удовлетворяют условия.
*/
/* При помощи данного метода мы вытащили данные по конкретному пользователю*/
// const userNadya = people.find(person=>person.name === 'Nadya');
// console.log(userNadya);

/*----------------------------------------------------------------------------------*/

/*
!! Метод findIndex
Метод arr.findIndex – по сути, то же самое, но возвращает индекс, на котором был найден элемент, а не сам элемент, и -1, если ничего не найдено
*/
/* В примере ниже мы нашли индекс пользователя в массиве*/
// const userNadya = people.findIndex(person => person.name === 'Nadya');
// console.log(userNadya);

/*----------------------------------------------------------------------------------*/
/*
!! Запись методов по цепочке (chain)
Если нам необходимо провести ряд действий с массивом в ходе чего мы будем использовать разные методы, то рекомендуеться использовать запись методов по цепочке, каждый метод записываеться с новой строки. Только нужно не забывать что возращает тот или иной метод, так как некоторые методы изменяют исходный массив. При записи по цепочке после каждого метода мы не ставим никаких знаков, ни ';' ни ',' .
*/
/* Ниже мы использовали методы по цепочке, тоесть сначала мы отфильтровали данные в массиве и одбросили пользователей с бюджетом ниже чем указано в условии. Далее используя метод map мы форматируем наш новый массив, вместо бывших полей name и age мы ставим поле info, а строку budget передаем в новую строку бюджет, если этого не сделать то строка бюджет не будет перенесена в новый массив. В цепочку можно добавить и другие методы, однако в таком случае нужно принимать во внимание что собственно в конечном итоге мы получим. Так к примеру если мы в текущую цепочку добавим метод reduce то получим к примеру сумму бюджетов отфильтрованных пользователей, однако результат метода map не будет виден в этом случае, так как метод reduce нам вернет число а не массив, по этому использовать этих два метода в данном случае не целесообразно. Их целесообразно использовать вместе только тогда когда в методе map мы будем проводить манипуляции с числами, тоесть к примеру бюджет умножим на процент отчеслений, таким образом мы получим итоговую сумму по отчислениям*/
// const newPeople = people
//     .filter(person => person.budget > 3000)
//     .map(person => {
//         return {
//             info: `${person.name} (${person.age})`,
//             budget:person.budget
//         }
//     })
// console.log(newPeople);

/* Ниже используя запись методов массива по цепочке мы выполнили ряд следующих действий: 1. при помощи метода filter отфильтровали массив, а именно исключили пользователей с бюджетом ниже 3000, так как с них не взымаеться налог. 2. при помощи метода map мы изменили данные в новом массиве, а именно бюджет каждого пользователя умножили на 5% - это сумма налоговых отчеслений. 3. при помощи метода reduce мы получили итоговую сумму отчеслений по всем отфильтрованным пользователям*/
// const totalTax = people
//     .filter(person => person.budget > 3000)
//     .map(person => person.budget * 0.05)
//     .reduce((total, person) => total + person, 0);
// console.log(totalTax);

/*----------------------------------------------------------------------------------*/

/*
!! ДОПОЛНИТЕЛЬНЫЕ МЕТОДЫ ДЛЯ МАССИВОВ

!! Метод Array.isArray
Массивы не образуют отдельный тип языка. Они основаны на объектах.
Поэтому typeof не может отличить простой объект от массива. Но массивы используются настолько часто, что для этого придумали специальный метод: Array.isArray(value). Он возвращает true, если value массив, и false, если нет.
*/
// console.log(Array.isArray(arrayTwo));
// console.log(Array.isArray(user));

/*----------------------------------------------------------------------------------*/

/*
!! Метод bind
Метод bind() создаёт новую функцию, которая при вызове устанавливает в качестве контекста выполнения this предоставленное значение. В метод также передаётся набор аргументов, которые будут установлены перед переданными в привязанную функцию аргументами при её вызове.
? fun.bind(thisArg[, arg1[, arg2[, ...]]])
thisArg - Значение, передаваемое в качестве this в целевую функцию при вызове привязанной функции. Значение игнорируется, если привязанная функция конструируется с помощью оператора new.

Тоесть инными словами метод для функций bind позволяет нам добавлять в объекты новые значения при вызове данного метода в контексте this, однако нужно еще почитать за данный метод и функции и понять как возвращать не просто в консоль а именно возвращать некий результат куда будет собствено передано аргументы.
*/

// const someInfo = {
//     name: 'Ivan',
//     age: 20,
//     addInfo: function (job, from) {
//         console.log(`Name is ${this.name}`)
//         console.log(`Age is ${this.age}`)
//         console.log(`Job is ${job}`)
//         console.log(`From is ${from}`)
//     }
// };

// const Nadya = {
//     name: 'Nadya',
//     age: 35,
// };
// someInfo.addInfo.bind(Nadya, 'Customer support', 'Kharkiv')()



/*----------------------------------------------------------------------------------*/
/*
!! ПРОТОТИПЫ
Помимо основных методов, можно создавать собственные методы при помощи прототипов. Прототипы - это механизм, с помощью которого объекты JavaScript наследуют свойства друг от друга. Тоесть если нам необходимо проводить какие то действия с массивом или обьектом неоднократно, то для упрощения кода и уменшения количества експортов можно как раз создать свой прототип при вызове которого мы и будем выполнять необходимые действия. При записи необходимо на первом уровне использовать функциональное выражение с применением ключевого слова function, так как стрелочная функция не видит контекст this, тоесть она не понимает на что мы ссылаемся.
*/
// Array.prototype.fnMultBy = function (n) {
//     return this.map((i) => {
//         return i * n
//     })
// };

/*Короткая запись*/
// Array.prototype.fnMultBy = function (n) {return this.map((i) => i * n)};
// console.log('Вывод созданого метода fnMultBy:', numberArr.fnMultBy(3));


/*----------------------------------------------------------------------------------*/
/*
!! ШПАРГАЛКА ПО МЕТОДАМ МАССИВОВ:

? Для добавления/удаления элементов:

push (...items) – добавляет элементы в конец,
pop() – извлекает элемент с конца,
shift() – извлекает элемент с начала,
unshift(...items) – добавляет элементы в начало.
splice(pos, deleteCount, ...items) – начиная с индекса pos, удаляет deleteCount элементов и вставляет items.
slice(start, end) – создаёт новый массив, копируя в него элементы с позиции start до end (не включая end).
concat(...items) – возвращает новый массив: копирует все члены текущего массива и добавляет к нему items. Если какой-то из items является массивом, тогда берутся его элементы.

?Для поиска среди элементов:

indexOf/lastIndexOf(item, pos) – ищет item, начиная с позиции pos, и возвращает его индекс или -1, если ничего не найдено.
includes(value) – возвращает true, если в массиве имеется элемент value, в противном случае false.
find/filter(func) – фильтрует элементы через функцию и отдаёт первое/все значения, при прохождении которых через функцию возвращается true.
findIndex похож на find, но возвращает индекс вместо значения.

?Для перебора элементов:

forEach(func) – вызывает func для каждого элемента. Ничего не возвращает.

?Для преобразования массива:

map(func) – создаёт новый массив из результатов вызова func для каждого элемента.
sort(func) – сортирует массив «на месте», а потом возвращает его.
reverse() – «на месте» меняет порядок следования элементов на противоположный и возвращает изменённый массив.
split/join – преобразует строку в массив и обратно.
reduce(func, initial) – вычисляет одно значение на основе всего массива, вызывая func для каждого элемента и передавая промежуточный результат между вызовами.

?Дополнительно:

Array.isArray(arr) проверяет, является ли arr массивом.
Обратите внимание, что методы sort, reverse и splice изменяют исходный массив.

Изученных нами методов достаточно в 99% случаев, но существуют и другие.

arr.some(fn)/arr.every(fn) проверяет массив.

Функция fn вызывается для каждого элемента массива аналогично map. Если какие-либо/все результаты вызовов являются true, то метод возвращает true, иначе false.

arr.fill(value, start, end) – заполняет массив повторяющимися value, начиная с индекса start до end.

arr.copyWithin(target, start, end) – копирует свои элементы, начиная со start и заканчивая end, в собственную позицию target (перезаписывает существующие).

Полный список есть в справочнике https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array.
*/


